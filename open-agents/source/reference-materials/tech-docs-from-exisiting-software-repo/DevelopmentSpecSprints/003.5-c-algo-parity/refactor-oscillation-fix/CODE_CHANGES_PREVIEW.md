# Specific Code Changes Preview

## Change 1: Remove Oscillatory Envelopes from `build_waypoints()`

**Location:** Lines 330-345 in ColorJourney.c  
**Severity:** Low  
**Impact:** Eliminates sine-wave undulation in waypoint creation

### BEFORE (Current - Oscillatory):
```c
/* Create waypoints with non-linear hue distribution */
const int num_waypoints = 8;

j->waypoint_count = num_waypoints;
for (int i = 0; i < num_waypoints; i++) {
    float t = (float)i / (float)(num_waypoints - 1);
    
    /* Non-linear hue progression using smoothstep */
    float hue_t = smoothstep(t);
    
    j->waypoints[i].anchor.h = base.h + hue_t * 2.0f * M_PI;
    
    /* Subtle chroma variation - peak at golden ratio point */
    float chroma_envelope = 1.0f + 0.2f * sinf(t * M_PI);  // ← OSCILLATES
    j->waypoints[i].anchor.C = base.C * chroma_envelope;
    
    /* Lightness gentle wave */
    float lightness_envelope = 1.0f + 0.1f * sinf(t * 2.0f * M_PI);  // ← OSCILLATES
    j->waypoints[i].anchor.L = base.L * lightness_envelope;
    
    j->waypoints[i].weight = 1.0f;
}
```

### AFTER (Proposed - Smooth):
```c
/* Create waypoints with non-linear hue distribution */
const int num_waypoints = 8;

j->waypoint_count = num_waypoints;
for (int i = 0; i < num_waypoints; i++) {
    float t = (float)i / (float)(num_waypoints - 1);
    
    /* Non-linear hue progression using smoothstep */
    float hue_t = smoothstep(t);
    
    j->waypoints[i].anchor.h = base.h + hue_t * 2.0f * M_PI;
    
    /* No chroma envelope - let interpolation be smooth */
    j->waypoints[i].anchor.C = base.C;
    
    /* No lightness envelope - preserve base lightness */
    j->waypoints[i].anchor.L = base.L;
    
    j->waypoints[i].weight = 1.0f;
}
```

---

## Change 2: Remove Chroma Pulse Overlay from `cj_journey_discrete()`

**Location:** Lines 815-835 in ColorJourney.c  
**Severity:** Low  
**Impact:** Removes post-hoc periodic wave pattern that creates rhythm artifacts

### BEFORE (Current - Pulsing):
```c
/* ========== PERIODIC CHROMA PULSE (WASM Enhancement) ==========
 * For large palettes (>CJ_CHROMA_PULSE_MIN_COLORS), apply a periodic
 * chroma modulation to create intentional "rhythm" in saturation across
 * the palette. This produces more "musical" color spacing that feels
 * more curated.
 * 
 * Formula: chroma_pulse = 1.0 + 0.1 * cos(i * π/5)
 * ...
 */
if (count > CJ_CHROMA_PULSE_MIN_COLORS) {
    for (int i = 0; i < count; i++) {
        /* Convert to OKLab to access chroma */
        CJ_Lab lab = cj_rgb_to_oklab(out_colors[i]);
        CJ_LCh lch = cj_oklab_to_lch(lab);
        
        /* Apply periodic pulse */
        double chroma_pulse = 1.0 + 0.1 * cos((double)i * M_PI / 5.0);
        lch.C = (float)((double)lch.C * chroma_pulse);
        lch.C = clampf(lch.C, 0.0f, 0.4f);
        
        /* Convert back to RGB */
        lab = cj_lch_to_oklab(lch);
        out_colors[i] = cj_oklab_to_rgb(lab);
        out_colors[i] = cj_rgb_clamp(out_colors[i]);
    }
}
```

### AFTER (Proposed - Removed):
```c
/* Chroma pulse overlay removed - colors generated by primary curve only */
```

(Entire block deleted)

---

## Change 3: Simplify `apply_minimum_contrast()` from Multi-Strategy to L-Only

**Location:** Lines 670-720 in ColorJourney.c  
**Severity:** Medium  
**Impact:** Removes hue jumping and chroma scaling; uses stable L adjustment only

### BEFORE (Current - Multi-Strategy, Chaotic):
```c
static CJ_RGB apply_minimum_contrast(CJ_RGB color,
                                     const CJ_RGB* previous,
                                     float min_delta_e) {
    if (!previous) return color;

    CJ_Lab prev_lab = cj_rgb_to_oklab(*previous);
    CJ_Lab curr_lab = cj_rgb_to_oklab(color);
    
    /* Iterative refinement (up to CJ_CONTRAST_MAX_ITERATIONS) */
    const int max_iterations = CJ_CONTRAST_MAX_ITERATIONS;
    for (int iter = 0; iter < max_iterations; iter++) {
        float dE = cj_delta_e(curr_lab, prev_lab);
        
        if (dE >= min_delta_e) {
            /* Sufficient contrast achieved */
            break;
        }
        
        /* Calculate how much contrast we need */
        float shortfall = min_delta_e - dE;
        
        /* Try multiple adjustment strategies in sequence */
        
        /* Strategy 1: Adjust lightness */
        float direction = (prev_lab.L < 0.5f) ? 1.0f : -1.0f;
        float L_nudge = shortfall * 0.5f;  /* Use 50% of shortfall for L adjustment */
        curr_lab.L = clampf(curr_lab.L + direction * L_nudge, 0.0f, 1.0f);
        
        /* Check if L adjustment helped */
        dE = cj_delta_e(curr_lab, prev_lab);
        if (dE >= min_delta_e) {
            break;
        }
        
        /* Strategy 2: Adjust both a and b components */
        shortfall = min_delta_e - dE;
        CJ_LCh lch = cj_oklab_to_lch(curr_lab);
        
        /* Try rotating hue to increase separation */
        float hue_rotation = 0.2f;  /* ~11 degrees */
        lch.h += hue_rotation * (float)iter;  /* Increase rotation each iteration */
        while (lch.h >= 2.0f * M_PI) lch.h -= 2.0f * M_PI;
        
        /* And boost chroma if possible */
        if (lch.C > 1e-5f) {
            float scale = 1.0f + shortfall * 0.5f;
            lch.C = fminf(lch.C * scale, 0.4f);
        }
        
        curr_lab = cj_lch_to_oklab(lch);
    }

    CJ_RGB adjusted = cj_oklab_to_rgb(curr_lab);
    return cj_rgb_clamp(adjusted);
}
```

### AFTER (Proposed - L-Only, Stable):
```c
static CJ_RGB apply_minimum_contrast(CJ_RGB color,
                                     const CJ_RGB* previous,
                                     float min_delta_e) {
    if (!previous) return color;

    CJ_Lab prev_lab = cj_rgb_to_oklab(*previous);
    CJ_Lab curr_lab = cj_rgb_to_oklab(color);
    
    float dE = cj_delta_e(curr_lab, prev_lab);
    if (dE >= min_delta_e) {
        /* Already sufficient contrast */
        return color;
    }
    
    /* Single-pass L adjustment (monotonic, smooth) */
    float shortfall = min_delta_e - dE;
    
    /* Determine direction: always push away from previous color's L */
    float direction = (curr_lab.L >= prev_lab.L) ? 1.0f : -1.0f;
    if (direction > 0.0f && curr_lab.L > 0.95f) direction = -1.0f;  /* Cap at edge */
    if (direction < 0.0f && curr_lab.L < 0.05f) direction = 1.0f;
    
    /* Apply modest L adjustment */
    float L_nudge = shortfall * 0.8f;  /* Use 80% of shortfall */
    curr_lab.L = clampf(curr_lab.L + direction * L_nudge, 0.0f, 1.0f);
    
    CJ_RGB adjusted = cj_oklab_to_rgb(curr_lab);
    return cj_rgb_clamp(adjusted);
}
```

---

## Change 4: Update Constants (Optional Cleanup)

**Location:** Lines ~30-40 (macro definitions)  
**Severity:** Low  
**Impact:** Make algorithm intentions clearer

### Changes:
```c
/* OLD */
#define CJ_CHROMA_PULSE_MIN_COLORS 20
#define CJ_CONTRAST_MAX_ITERATIONS 5

/* NEW (after removal) */
/* REMOVED: CJ_CHROMA_PULSE_MIN_COLORS (no longer used) */
/* REDUCED: CJ_CONTRAST_MAX_ITERATIONS changed to 1 */
#define CJ_CONTRAST_MAX_ITERATIONS 1
```

---

## Change 5: Update `cj_journey_discrete()` Comment (Documentation)

**Location:** Lines ~780-800 in ColorJourney.c  
**Severity:** None (documentation only)  
**Impact:** Clarifies what the algorithm actually does now

### Updated Comment Block:
```c
/**
 * Generate a discrete palette with N evenly-spaced colors.
 * 
 * ALGORITHM:
 * 1. Sample journey at N evenly-spaced positions (0, 1/N, 2/N, ..., (N-1)/N)
 * 2. Enforce minimum contrast between adjacent colors using L adjustment
 * 3. Return colors as continuous array
 * 
 * No post-hoc oscillatory overlays or periodic modulation.
 * The primary curve is smooth and monotonic in 3D OKLab space.
 * 
 * DETERMINISM (Constitution Principle IV):
 * Output is deterministic given the same config and RNG seed.
 * 
 * PERCEPTUAL QUALITY (Constitution Principle II):
 * Colors maintain minimum ΔE contrast and span perceptual color space evenly.
 */
```

---

## Verification Checklist

After each change, verify:

- [ ] File compiles without warnings
- [ ] No regression in existing tests
- [ ] Visual output is smoother (inspect with OKLab3DViewer)
- [ ] Hue doesn't backtrack (check discrete palette sequence)
- [ ] Chroma doesn't oscillate (plot chroma values for 30-color palette)
- [ ] Lightness is monotonic or gently curved (not wavy)

---

## Implementation Sequence

1. **Change 1** (Remove envelopes): Recompile, run tests
2. **Change 2** (Remove pulse): Recompile, run tests
3. **Change 3** (Simplify contrast): Recompile, run tests, inspect output
4. **Change 4** (Constants): Recompile
5. **Change 5** (Documentation): No recompile needed

**Estimated time:** 30 min implementation + 15 min testing per change = ~2 hours total

