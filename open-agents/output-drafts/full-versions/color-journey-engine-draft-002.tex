\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{geometry}
\geometry{margin=1in}
\newcommand{\source}[1]{\texttt{#1}}

\title{The Color Journey Engine: Conceptual and Mathematical Design}
\author{}
\date{}

\begin{document}

\maketitle

\section{Introduction}

The \emph{Color Journey Engine} is a framework for generating smooth, perceptually uniform sequences of colours (or \emph{swatches}) between defined key colours, which we call \emph{anchor colours}. The engine ensures that colour transitions are aesthetically pleasing and mathematically well-defined by working in a modern perceptual colour space and by enforcing minimum and maximum perceptual distances between consecutive swatches. This paper presents the design of the engine in a self-contained manner, covering both high-level concepts and the underlying mathematics. Throughout, colours are converted to and processed in the OKLab space, which is chosen for its perceptual uniformity. The system adapts the number of swatches to the perceptual distance between anchors rather than fixing it \emph{a priori}, and it offers multiple interpolation strategies to suit different visual styles. The narrative here assumes no prior knowledge of earlier discussions; all necessary definitions and formulas are provided.

\section{Design Goals}

\paragraph{Reproducibility.} The engine produces deterministic outputs for a given input. In other words, the same set of anchor colours and parameters will always yield the same sequence of swatches. Any random variation introduced for stylistic diversity is controlled via a fixed seed to ensure \emph{pseudo-random determinism}—the randomness is repeatable when needed. This reproducibility is crucial for developers who require consistency across runs (for example, to regenerate a palette during development or to maintain a design system). By default, the engine forgoes randomness, but if variation is desired (e.g. to generate multiple palette options), it can inject controlled noise or perturbations with a known seed so that results remain trackable.

\paragraph{Perceptual Smoothness.} A primary goal is to achieve transitions that are smooth to the human eye. The engine works in a perceptually uniform colour space (OKLab) so that equal steps correspond roughly to equal perceived colour differences ￼. It enforces constraints on the minimum and maximum allowed colour difference between successive swatches, preventing both imperceptibly small changes and jarring jumps. By maintaining each step within a just-noticeable difference range (around 2–3 $\Delta E$ units ￼) and capping large differences (no single step much above 5 units, as differences above about 5 are readily noticeable ￼), the engine ensures a gentle, continuous journey. This perceptual regulation yields color gradients that appear uniform and without abrupt shifts or “dead zones.”

\paragraph{Flexibility.} The Color Journey Engine is designed to accommodate a variety of use cases and aesthetic preferences. It accepts between 1 and 5 anchor colours as input (more anchors give more complex journeys, while a single anchor trivially yields a static colour). The engine adapts the number of intermediate swatches to the anchors’ spacing, rather than using a fixed count, thereby handling both short and long colour transitions gracefully. It provides multiple interpolation \emph{strategies} (linear, curved, multi-phase, etc.) and exposes several continuous parameters to tweak the character of the journey. These options allow the user to emphasize different attributes—such as maintaining vibrancy vs.\ neutrality, or biasing towards warmth vs.\ coolness—without needing to directly manipulate colours. Despite this flexibility, the engine imposes sensible limits (for example, at most five subdivision segments between any two anchors) to keep palettes manageable in length and to prevent over-refinement. In effect, the system is general enough for a wide range of palettes (from subtle shifts to dramatic multi-hue transitions) while abstracting away low-level details.

\paragraph{Simplicity of Interface.} A guiding principle is to hide the complexity of colour science and path construction behind a simple API. The caller of the engine only needs to provide a small amount of information: the anchor colours (specified in a standard format like sRGB or hex) and optionally some stylistic parameters or a desired number of output swatches. The engine handles all internal conversions (to OKLab and back), computations, and constraint enforcement transparently. The output is structured in developer-friendly formats (discussed in Section~\ref{sec:output}) such as a list of colours or a JSON object, ready to be consumed in applications. This design goal ensures that developers without specialized knowledge in color theory can still leverage the engine to produce high-quality, perceptually tuned colour sequences. The interface is kept intuitive (e.g.\ specifying a “warmth” bias instead of manipulating hue angles manually), enabling quick experimentation and integration.

\section{Perceptual Colour Space: OKLab}

Colour interpolation and comparison benefit from being performed in a \emph{perceptually uniform} space. In such a space, equal Euclidean distances correspond more closely to equal perceptual differences. We adopt OKLab, introduced by Ottosson, which improves on the classic CIELAB space in terms of uniformity ￼. A colour in OKLab is represented by three coordinates $(L,a,b)$, where $L$ is perceived lightness, $a$ encodes roughly a green–red axis, and $b$ encodes a blue–yellow axis. OKLab is obtained from linear RGB through a sequence of linear transforms and a cube-root nonlinearity: first convert sRGB to a linearised XYZ; then apply a matrix $M_1$ to obtain LMS cone responses; apply a cube-root to each component; and finally apply another matrix $M_2$ to produce $(L,a,b)$. Full matrices are given in Ottosson’s work ￼; the details need not be reproduced here, but the transformation is invertible, allowing conversion back to sRGB when needed.

The perceptual distance between two colours $A=(L_A,a_A,b_A)$ and $B=(L_B,a_B,b_B)$ in OKLab is measured by the Euclidean norm
\begin{equation}
\Delta_{AB} = \sqrt{(L_B - L_A)^2 + (a_B - a_A)^2 + (b_B - b_A)^2},,
\end{equation}
which acts as a colour difference metric analogous to the $\Delta E^*$ measure in CIELAB ￼. By design of OKLab, a difference of $1.0$ in this space is on the order of a just-noticeable difference for an average observer (earlier literature often quotes a JND of about 2.3 in CIELAB ￼, and OKLab has similar intent). Differences of around two to three units are near the threshold of human perception, while differences above roughly five units are clearly perceptible ￼. The engine uses these values to regulate swatch spacing, as described later.

To convert between sRGB (our assumed input/output colour encoding) and OKLab, we employ two transformations: one into OKLab and one back out. In pseudo-code form:
\begin{verbatim}
struct Color { double r, g, b; };   // sRGB components in 0–1 range
struct Lab   { double L, a, b; };   // OKLab coordinates

Lab srgbToOklab(Color c) {
// (1) convert c from sRGB to linear XYZ;
// (2) apply matrix M1 to get LMS;
// (3) take cube-root of each component;
// (4) apply matrix M2 to get (L, a, b).
Lab lab;
// … computations …
return lab;
}

Color oklabToSrgb(Lab lab) {
// inverse of srgbToOklab: undo M2, cube roots, and M1.
Color c;
// … computations …
return c;
}
\end{verbatim}
These functions encapsulate the color space conversion. Implementations may use precomputed matrices for $M_1$ and $M_2$ to speed up these conversions. Once colours are represented in OKLab, interpolation and distance calculations become straightforward and meaningful in perceptual terms.

\section{Anchors, Swatches and Perceptual Distance Constraints}

\subsection{Anchors and Swatches}

The input to the engine is a sequence of \emph{anchor colours}. Anchors are the fixed colours that define key points along the desired palette or gradient. Between consecutive anchors, the engine generates intermediate colours called \emph{swatches}. A swatch sequence thus forms a continuous colour progression from one anchor to the next. Importantly, there is no globally fixed number of swatches; rather, the number of intermediate steps is determined adaptively from the perceptual distance between each pair of anchors.

Consider two anchors $A$ and $B$ given in OKLab coordinates. Their distance $D = \Delta_{AB}$ informs how many intermediate swatches are needed to transition from $A$ to $B$ smoothly. Two parameters govern the sampling density: a minimum allowed perceptual distance $\Delta_{\min}$ and a maximum allowed distance $\Delta_{\max}$ between adjacent colours. These thresholds are chosen so that successive colours are neither too similar (which would make the difference imperceptible and thus unnecessary) nor too far apart (which would cause an abrupt visual jump). In practice, typical values might be $\Delta_{\min} \approx 2$ and $\Delta_{\max} \approx 5$ in OKLab units ￼. If $D \le \Delta_{\max}$, one can place colour $B$ directly after $A$ with no intermediate swatches; if $D < \Delta_{\min}$, the colours are so close that they may be visually indistinguishable, and the system can treat them as essentially the same anchor (skipping interpolation altogether). Otherwise (for $\Delta_{AB}$ in a moderate range), we subdivide the interval into
\begin{equation}
n = \left\lceil \frac{D}{\Delta_{\max}} \right\rceil
\end{equation}
segments. By design we impose an upper bound such that $n \le 5$ (at most five segments per anchor pair) to keep the palette length manageable. Each segment then has length $D/n$, which guarantees it does not exceed $\Delta_{\max}$. The engine inserts $n-1$ intermediate swatches at fractional positions $t = i/n$ for $i=1,2,\dots,n-1$. Linearly interpolating in OKLab space yields a parametric path:
\begin{equation}
P(t) = A + t,(B - A) = \big(L_A + t(L_B - L_A),;; a_A + t(a_B - a_A),;; b_A + t(b_B - b_A)\bigr)
\end{equation}
for $0 \le t \le 1$. After computing $P(t)$ in OKLab, we convert each point back to the output colour space (e.g. sRGB) for display or use. This linear blend in OKLab produces a smooth transition that is nearly perceptually uniform.

Below is pseudocode illustrating the adaptive generation of swatches between two anchors:
\begin{verbatim}
const double DELTA_MIN = 2.0;
const double DELTA_MAX = 5.0;
const int    MAX_SEGMENTS = 5;

void addSegmentWithIntermediates(Color anchor1, Color anchor2, vector& out) {
Lab lab1 = srgbToOklab(anchor1);
Lab lab2 = srgbToOklab(anchor2);
double D = oklabDistance(lab1, lab2);
if (D < DELTA_MIN) {
// colours nearly identical: append only the second anchor
out.push_back(anchor2);
return;
}
int segments = (int)ceil(D / DELTA_MAX);
if (segments > MAX_SEGMENTS) segments = MAX_SEGMENTS;
for (int i = 1; i <= segments; ++i) {
double t = (double)i / segments;
Lab interp;
interp.L = lab1.L + t * (lab2.L - lab1.L);
interp.a = lab1.a + t * (lab2.a - lab1.a);
interp.b = lab1.b + t * (lab2.b - lab1.b);
Color c = oklabToSrgb(interp);
out.push_back(c);
}
}
\end{verbatim}
In this procedure, the vector \texttt{out} accumulates the sequence of colours; each call to \texttt{addSegmentWithIntermediates} inserts enough swatches so that successive colours differ by at most $\Delta_{\max}$. Users may provide up to five anchor colours; the engine processes each adjacent pair of anchors in turn and concatenates all the resulting swatches (omitting duplicate anchors at the junctions). The design imposes a hard maximum of five segments (four intermediate swatches) between any two anchors to balance perceptual precision with palette length, as noted above.

\begin{figure}[h]
\centering
\includegraphics[width=0.75\textwidth]{anchor_to_anchor_curve.jpeg}
\caption{Adaptive sampling of a colour journey between two anchors $A$ and $B$ in OKLab space. The straight line from $A$ to $B$ (dashed) is sampled at $n=5$ evenly spaced points, here yielding three intermediate swatches (solid dots between $A$ and $B$) after excluding the end-points. Each segment of the path is within the maximum allowed distance $\Delta_{\max}$, producing a smooth transition.}
\end{figure}

\subsection{Multi-Anchor Journeys}

When more than two anchors are provided, the journey becomes a chain of segments $\gamma_0, \gamma_1, \dots$ connecting $A_0$ to $A_1$, then $A_1$ to $A_2$, and so forth through the anchor list. Formally, if anchors are $A_0, A_1, \ldots, A_m$, we construct segment $\gamma_i$ from $A_i$ to $A_{i+1}$ for $i=0,1,\dots,m-1$. A continuity condition naturally holds: $\gamma_i(1) = A_{i+1} = \gamma_{i+1}(0)$, meaning the end of one segment is exactly the start of the next. The engine processes each segment independently using the aforementioned adaptive subdivision logic, then concatenates the swatches from all segments (taking care not to duplicate anchor colours at the boundaries). By handling segments one at a time, the complexity remains linear in the number of anchor pairs.

For a visually smooth overall trajectory across multiple segments, one may optionally enforce continuity not just in colour value but also in first derivative at the anchor junctions. In other words, we can strive for $C^1$ continuity by matching the gradient of the path as it enters and leaves each intermediate anchor. In practice, this can be achieved by using a parametric curve (like a Bézier curve) for each segment and adjusting control points such that the outgoing tangent from anchor $A_{i+1}$ in segment $\gamma_i$ equals the incoming tangent to $A_{i+1}$ in segment $\gamma_{i+1}$. For example, if $P_1$ and $P_2$ are the control points of the Bézier curve used for segment $\gamma_i$ (with $P_2$ being the control point adjacent to anchor $A_{i+1}$), we can choose the first control point $Q_1$ of the next segment $\gamma_{i+1}$ to be $Q_1 = A_{i+1} + (A_{i+1} - P_2)$. This symmetric placement mirrors $P_2$ on the opposite side of $A_{i+1}$, ensuring the tangents match. In summary, while the default piecewise linear concatenation of segments yields a continuous (but potentially $C^0$ only) path, an enhanced mode can smooth the corners at anchors using curve constructions, as detailed later in the context of Bézier representations.

\section{Colour Transition Strategies}

The engine offers several \emph{interpolation strategies} for determining the path between two anchors. These define how the colour coordinates change along a segment in perceptual space. Some strategies are internal and always applied (e.g. gamut clamping and distance enforcement), while others are user-selectable to allow different stylistic effects. We outline both categories below.

\subsection{Internal Strategies}

These strategies are applied by the engine automatically to maintain coherence and validity, and they are not directly controlled by the user:

\begin{itemize}
\item \textbf{Perceptual distance enforcement.} As described above, the engine enforces $\Delta_{\min} \le \Delta \le \Delta_{\max}$ for the difference $\Delta$ between any two adjacent swatches. This rule prevents redundant near-duplicates (which would occur if $\Delta$ were below the perception threshold) and also prevents large jumps that would break the smoothness. Essentially, it guarantees that each step is noticeable yet not overwhelming.
\item \textbf{Gamut clamping.} Linear interpolation in OKLab or certain curved paths may produce intermediate colours that fall outside the displayable sRGB gamut (for instance, an interpolated colour might require an RGB component slightly above 1.0 or below 0.0 after conversion). The engine automatically maps any out-of-gamut colour back into the valid range $[0,1]$ for each RGB channel, typically by reducing the chroma (saturation) while preserving the hue and lightness, until the colour lies within gamut. This approach ensures that all generated swatches can be represented and displayed without distortion. The clamping is done in a perceptually sensitive way (desaturating rather than simply chopping channels) and is an internal mechanism not exposed as an option.
\item \textbf{Hue wrapping.} When dealing with hue-based interpolation (such as in polar OKLCH coordinates), the engine must handle the circular nature of the hue dimension. By default, it always takes the shorter path around the hue circle. In practice, this means if one anchor has a hue of 10° and the next has 350°, the interpolation will go backward through 0° (via 360° back to 350°) rather than forward through  ten degrees vs. a 340-degree difference). This avoids an unintended long detour around the colour wheel when crossing the 0/360 boundary. The system automatically applies this “wrap-around” selection of the minimal hue difference.
\item \textbf{Implicit smoothing at anchors.} As noted, when three or more anchors are present, the piecewise path can have sharp corners (a sudden change in direction) at each anchor. The engine can optionally smooth these transitions. One method is to insert a very short additional segment near the anchor or to slightly adjust the first or last swatch on each side so that the trajectory bends gently instead of making an abrupt turn. This smoothing is analogous to using a spline or Bézier curve through the anchors rather than a polyline. In the current design, we implement it by adjusting Bézier control points (detailed in Section 5): effectively, the control points on either side of an anchor are set collinear with the anchor, which blends the segments into a continuous curve. This internal smoothing can be enabled for an overall softer look, but is not explicitly a user-facing setting (it is triggered by the engine when it deems necessary, such as when the user’s chosen style parameters favor high smoothness).
\end{itemize}

\subsection{Exposed Strategies}

Beyond the behind-the-scenes adjustments above, the engine allows the user to choose among several high-level interpolation \emph{styles} for the colour journey between two anchors. Each strategy defines a different continuous path $P(t)$ in OKLab (or a related space) from the start to end colour. After the path is defined, the engine still samples it according to the distance constraints already discussed. We describe the main options provided:

\paragraph{Direct Linear Interpolation.} The default strategy is a straight-line interpolation in the OKLab space between two anchors, as given by the formula in equation (3). Because OKLab is nearly perceptually uniform, a linear blend in $(L,a,b)$ generally produces a smooth and balanced transition between colours ￼. In this mode, all three coordinates $L$, $a$, and $b$ change at constant rates. One characteristic of linear Lab interpolation is that if the anchors differ strongly in hue, the intermediate colour tends to have slightly reduced chroma (it can appear a bit desaturated or “greyed out” at mid-point). This is a natural consequence of the straight line in Lab often cutting closer to the neutral axis of the colour space. The direct linear strategy is computationally simple and works well as a default for many situations.

\paragraph{Chromatic Curve (OKLCH Interpolation).} To maintain higher saturation and produce more vivid intermediate hues, another strategy converts the anchors to OKLCH (the polar form of OKLab) and interpolates in terms of lightness $L$, chroma $C$, and hue angle $h$ separately. In OKLCH, $L$ is the same perceptual lightness as in Lab, $C = \sqrt{a^2 + b^2}$ represents the chroma (distance from the grey axis), and $h = \arctan2(b,a)$ is the hue angle. For anchors with polar coordinates $(L_A, C_A, h_A)$ and $(L_B, C_B, h_B)$, we define the trajectory by:
\begin{equation}
L(t) = L_A + t (L_B - L_A), \qquad
C(t) = C_A + t (C_B - C_A), \qquad
h(t) = h_A + t,\Delta h~,
\end{equation}
where $\Delta h$ is the minimal signed hue difference taking into account wrap-around (as described above). We then convert the path $(L(t), C(t), h(t))$ back to Cartesian Lab via $a = C(t)\cos h(t)$, $b = C(t)\sin h(t)$. The result is a path that tends to “hug the surface” of the colour solid (staying at relatively high chroma) ￼ ￼. This means the intermediate colours will be more vibrant and less muddy than the linear-Lab path. In cases where the two anchors are very different in hue, the OKLCH interpolation yields a pronounced hue rotation with saturated intermediate colours (for example, blending red to blue might give a bright purple midpoint, instead of the duller purple from linear Lab). The engine exposes this as a \textit{vibrant} or “chromatic” mode for users who prefer to preserve colourfulness throughout the journey.

\begin{figure}[h]
\centering
\includegraphics[width=0.75\textwidth]{vibrant_vs_linear.jpeg}
\caption{Comparison of interpolation strategies between two disparate colours. \emph{Top:} Direct linear interpolation in OKLab, which passes closer to the neutral center of colour space—note the intermediate appears desaturated. \emph{Bottom:} OKLCH (chromatic) interpolation, which maintains higher chroma by traveling around the “surface” of the space—yielding a more vibrant intermediate. Both paths are sampled under the same distance constraints.}
\end{figure}

\paragraph{Two-Phase Strategies.} These strategies implicitly introduce an extra “virtual” anchor in the middle so that the journey happens in two distinct stages: first changing one attribute of colour, then the other. They are especially useful when the starting and ending anchors differ significantly in \emph{both} hue and lightness, as a single interpolating curve might produce an unsatisfying intermediate (too dark, too bright, or a strange hue cast). We offer two variants:
\begin{itemize}
\item \textbf{Lightness-First.} In this mode, the transition first adjusts lightness, then hue/chroma. We construct a temporary intermediate colour $M$ that shares the hue (and roughly the chroma) of the start anchor $A$, but has the lightness of the target $B$. For example, in Lab coordinates, let $M = (L_B,; a_A,; b_A)$ (meaning we set $M$’s $L$ to $L_B$ while keeping $a,b$ as from $A$). Now we form the journey in two legs: $A \rightarrow M$ and then $M \rightarrow B$. Each leg is itself interpolated with the standard (linear or default) method and sampled with the distance-based rule. Visually, the colour will lighten or darken from $A$ to match $B$’s brightness first, then it will shift in hue to reach $B$. The effect is that the largest lightness differences are resolved early, which can help avoid overly dark or bright midpoints that might occur in a one-step interpolation.
\item \textbf{Hue-First.} This is the converse: change the hue first, then the lightness. We construct $M$ such that it carries the hue of $B$ but the lightness of $A$. In OKLCH terms, we set $L_M = L_A$, $h_M = h_B$, and we choose a chroma $C_M$ close to that of $A$ (for continuity—perhaps the average of $C_A$ and $C_B$ or just $C_A$). Then we interpolate $A \rightarrow M$ followed by $M \rightarrow B$. In the first leg, the hue rotates towards $B$’s hue while the lightness stays as $A$’s (maintaining a consistent brightness through the middle of the journey), and in the second leg, we adjust the lightness from $L_A$ to $L_B$. The hue-first approach keeps the middle portion of the journey at a similar lightness to the endpoints, which can be desirable if one wants to avoid a pronounced brightness dip or spike in the middle.
\end{itemize}

\paragraph{Neutral Pivot.} For extremely distant hues where even the chromatic interpolation yields a strange intermediate (for instance, blending a saturated yellow to a saturated blue might give a brownish-gray midpoint), a technique is to insert a neutral grey as an intermediate anchor. We call this a neutral pivot strategy. Essentially, the journey goes $A \rightarrow N \rightarrow B$, where $N$ is a grey or off-white of intermediate lightness (often one chooses $N$ to have the average lightness of $A$ and $B$, and zero chroma). The first half $A \to N$ washes out $A$ to neutral, and the second half $N \to B$ imbues the hue of $B$. This produces a “fade to grey, then revive” effect. It is not perceptually uniform in hue trajectory, but it can be useful as a stylistic choice to avoid unwanted intermediate hues. The engine may expose this as an optional mode (likely not default, since it’s a special effect).

\paragraph{Continuation and Loop Strategies.} Normally, a palette journey is \emph{open}: it starts at the first anchor and ends at the last anchor. However, in some applications, one might want a cyclic or extended palette that goes beyond the provided anchors, effectively looping or repeating the journey. The engine supports this when the user requests more swatches than are strictly needed for a single pass from start to end (i.e. beyond the perceptually justified number). If looping is enabled (see Section 6.2), the engine will extend the colour sequence by repeating or mirroring the base journey in some manner. Several internal loop topologies are defined:
\begin{itemize}
\item \emph{Tiled Loop:} This simplest approach just repeats the anchor sequence periodically. If $\gamma:[0,1] \to \mathbb{R}^3$ is the path through OKLab for one full journey from the first to last anchor, the extended journey can be defined for $u \ge 0$ by $\Gamma(u) = \gamma(u \bmod 1)$. In effect, after reaching the last anchor, the palette wraps directly back to the first anchor and continues. This yields a closed loop but with a potential jump (unless the end and start anchors were identical or very close). Typically, this mode would be used only if the endpoints are deliberately chosen to be similar (to make a seamless loop).
\item \emph{Ping-Pong Loop:} Another strategy is to traverse the journey forward, then backwards, then forward again, and so on. This is analogous to bouncing back and forth (hence “ping-pong”). Formally, one can define a phase-adjusted parameter $\tilde{t}$ over an interval $[0,2]$ such that for $0 \le u < 1$, $\tilde{t}=u$ (going forward), and for $1 \le u < 2$, set $\tilde{t} = 2 - u$ (going backward from 1 back down to 0). Then extend this periodically beyond $u=2$. The result is a palette that goes from $A_0$ to $A_m$ (last anchor), then back to $A_0$, in a smooth reversible way. This avoids any jump at the loop point, since the end of the first cycle meets the start in the same colour.
\item \emph{Phased Loop:} In a phased loop, each repetition of the journey applies a systematic shift to the colours, so that the palette changes slightly with each cycle rather than repeating exactly. For example, one can add a constant small increment to the hue for each loop iteration (rotating all colours by a few degrees each time), or slightly increase/decrease all lightness values on each cycle. If $h$ is the hue coordinate, one might set $h \mapsto h + k ,\Delta h$ for the $k$-th cycle. Over multiple cycles this produces a spiral through colour space rather than retracing the same ring. Eventually it may wrap around, depending on the increments. Phased loops create a sense of progression or evolution, at the cost of eventually deviating from the original anchors (so they are used when continuous novelty is desired).
\item \emph{Möbius Loop:} This exotic option introduces a twist in the looping such that the second cycle inverts certain attributes relative to the first, requiring two cycles to return to the start. The name comes by analogy to a Möbius strip, which has a 180° twist—here the colour journey might, for instance, flip hue direction or invert lightness on alternate cycles. Concretely, one could design the second lap of the journey to traverse the complementary path (e.g. going from last anchor back to first but in hue-space going the long way around instead of the short way, or reflecting all hues across some axis). After two cycles, it realigns with the starting point. A Möbius loop yields a palette that changes on each repetition in a non-trivial way yet eventually is cyclical after two iterations. This can produce an interesting effect for continuously cycling UI elements or dynamic lighting.
\end{itemize}
The loop topology is chosen internally based on the user’s request (notably, the number of swatches beyond the first pass) and possibly the stylistic parameters. The user does not directly select “ping-pong vs Möbius” etc.; instead, they indicate whether looping is desired and perhaps a bias (e.g. “allow variations each loop” could nudge towards phased or Möbius vs. a simple tile loop). The engine then ensures the extended palette remains smooth at the transition point and adheres to the overarching style.

\section{Stylistic Parameters}

While the engine operates with rigorous perceptual defaults, it provides users with intuitive controls that steer the appearance of the colour journey without requiring detailed knowledge of the underlying math. These \emph{stylistic parameters} map to adjustments in the interpolation curves (e.g. via control points of Bézier curves or choice of loop strategy). By tuning these, the caller can achieve different “looks” (warm vs. cool, vivid vs. muted, etc.) while still benefiting from the engine’s automatic constraints. We first describe the internal representation that makes these controls possible, and then the controls themselves.

\subsection{Bézier Representation and Control Point Nudging}

Within each segment (between two anchors), the engine is capable of representing the colour path as a cubic Bézier curve in OKLab space. A Bézier curve offers a flexible way to shape the interpolation, going beyond a straight line while ensuring a smooth parametric form. A cubic Bézier with endpoints $P_0$ (start) and $P_3$ (end) and control points $P_1, P_2$ (which influence the departure and approach directions) is given by the polynomial:
\begin{equation}
\gamma(t) = (1-t)^3 P_0 ;+; 3(1-t)^2 t, P_1 ;+; 3(1-t) t^2, P_2 ;+; t^3 P_3, \qquad 0 \le t \le 1~.
\end{equation}
At $t=0$ and $t=1$ this yields $\gamma(0)=P_0$ and $\gamma(1)=P_3$. The first derivative (tangent) at the endpoints are $\gamma’(0) = 3(P_1 - P_0)$ and $\gamma’(1) = 3(P_3 - P_2)$. Thus $P_1$ controls the initial direction of the curve leaving $P_0$, and $P_2$ controls the incoming direction into $P_3$. As noted in the multi-anchor discussion, to extend a journey continuously beyond an anchor, one can set up the next segment’s first control $Q_1$ to align with the previous segment’s last control $P_2$ such that $Q_1 = P_3 + (P_3 - P_2)$, making $\gamma’(1)$ for the first segment equal and co-linear to $\gamma’(0)$ of the next. This yields $C^1$ continuity.

The engine uses a default placement for control points in each segment (essentially a straight line path where $P_1$ and $P_2$ lie on the line $P_0P_3$, which reduces the Bézier to a straight line). Then, based on the user’s stylistic parameters, it \emph{nudges} these control points to alter the curve. For example, pulling $P_1$ and $P_2$ off the line can introduce a gentle curvature—perhaps moving them in the direction of higher chroma or towards a particular hue if requested. All adjustments to $P_1,P_2$ are done subject to constraints: we ensure the new control points still yield a curve that stays within the allowed gamut (if a control point goes out of sRGB range in the conversion, we might slide it back or reduce its chroma until the curve segment is entirely in gamut). Similarly, we ensure that the curve does not loop back on itself or create inflection points that would violate the single-valued nature of the journey. In essence, the Bézier formulation provides “handles” that the engine can move in response to parameter changes, thereby modulating the shape of the colour trajectory.

\subsection{User Controls: Lightness, Chroma, Warmth, and Smoothness} \label{sec:controls}

The engine exposes a few high-level knobs to the user, each ranging over a specified interval, that influence the journey’s character in meaningful ways. These controls correspond to common intuitive notions:
\begin{itemize}
\item \textbf{Temperature (Warmth)} – range $[-1, +1]$. This biases the overall hue of the journey toward cooler or warmer tones. At 0 (neutral), the engine follows the direct hue path between anchors. At +1 (fully warm), the engine will subtly steer intermediate hues toward the warm side of the colour wheel (reds, oranges, yellows), whereas at -1 (cool) it will favour greens, blues, and purples. Implementation-wise, this might shift the control points’ hue: for example, if the raw path in OKLab is neutral, a warm bias could add a small positive offset to the hue angles of $P_1$ and $P_2$, causing the path to loop slightly through warmer hues. The effect is a gentle tint: a warm bias can make the whole transition feel “sunset-like”, while a cool bias can make it feel “ocean-like”. The anchors themselves remain fixed; the bias influences only the intermediate mix.
\item \textbf{Intensity (Vibrancy)} – range $[0, 1]$. This governs how far the journey pushes out into high-chroma regions versus staying near the straight line. An intensity of 0 results in minimal chroma deviation — the colour path will be nearly the straight line in Lab (perhaps just enough curvature to meet other constraints), producing a modest, restrained transition with maybe some slight greying at midpoints. An intensity of 1, by contrast, pulls the Bézier control points outward to maximize chroma, producing very vivid intermediate colours. One way to implement this is: given the anchors $P_0$ and $P_3$, first define $P_1$ and $P_2$ on the line $P_0P_3$ (for a straight line path). Then compute two candidate offsets perpendicular to that line (in the $a,b$ plane mainly, since lightness changes are usually monotonic) that would increase the chroma — essentially pushing $P_1$ and $P_2$ outward in opposite directions in the Lab space. With intensity = 1, we apply the full offset to $P_1,P_2$; with intensity = 0.5, we apply half the offset, etc. The offsets are chosen so that $P_1$ and $P_2$ still yield a valid in-gamut curve and do not violate distance constraints when sampled. The result is that higher intensity yields a more curved path that preserves saturation (like the OKLCH strategy) and low intensity yields a straighter path (like linear Lab). This parameter effectively corresponds to how “vibrant” or “muted” the gradient will appear.
\item \textbf{Contrast (Lightness Range)} – range $[0, 1]$. Although not explicitly mentioned in the earlier sections, one could offer a control for overall contrast of the palette. This could adjust the lightness span of the journey. For example, at contrast 1, the engine might allow the full difference in anchor lightness to manifest (or even exaggerate it slightly by pushing the darks darker and lights lighter, if possible), whereas at contrast 0, it might compress the lightness differences, keeping the palette more uniform in brightness. This can be implemented by adjusting the $L$ coordinates of intermediate swatches: a higher contrast setting could nonlinear scale $L(t)$ values to increase dynamic range (e.g. using a slight easing function that makes midtones slightly darker if anchors span a wide $L$ range), while a lower contrast setting does the opposite. In practice, extreme use of this parameter can conflict with anchor fidelity (we typically do not want to change anchor values), so it is applied subtly. It is mainly useful if the user wants a flatter look (low contrast) or a punchier look (high contrast) regardless of anchor choices.
\item \textbf{Smoothness} – range $[0, 1]$. This controls the evenness of curvature and the degree of corner smoothing at anchors. At 1.0, the engine prioritizes a very gentle, $C^1$-continuous path: it will aggressively adjust control points to iron out any kinks, potentially adding slight overshoot if needed to maintain derivative continuity. At 0.0, the engine is allowed to form sharper transitions: it will place control points closer to the anchors, making the curve sections closer to straight lines meeting at the anchor (essentially $C^0$ continuity, possibly with a visible corner, though still in gamut and within distance limits). Smoothness thus lets the user decide between a very flowy, gradual palette vs. a more “edgy” or quickly changing palette. It’s like controlling how rounded the bends are in a multi-anchor path. Implementation-wise, this parameter could interpolate between the scenario of matching tangents at anchors (for smoothness=1) and leaving them unmatched (for smoothness=0), by adjusting how $P_1,P_2$ are mirrored around anchors.
\item \textbf{Loop Enable}. This is a boolean flag (or a mode selection) rather than a continuous value. If enabled, the engine will treat the palette as cyclic or extendable, employing one of the continuation strategies described in the previous section to generate additional swatches beyond the first pass. If disabled (the default), the palette is an open journey from the first to last anchor with no repetition. When loop mode is on, the specific loop strategy used (tile, ping-pong, phased, Möbius) may be chosen automatically based on the context and possibly influenced by the other parameters: e.g. a high intensity and a warm bias might incline the engine to use a phased loop with a slight hue shift each cycle (creating a swirling effect), whereas a neutral setting might default to a ping-pong or tile loop for a simple back-and-forth oscillation. In all cases, enabling loop ensures that the output list of colours can exceed the number available in a single journey by recycling or extending the path smoothly.
\end{itemize}

These controls map directly to mathematical adjustments in the engine’s internal calculations. For example, as mentioned, the temperature (warmth) slider effectively rotates the hue of intermediate control points; intensity scales a chroma offset vector for the Bézier handles; smoothness adjusts how control points on adjacent segments are aligned or separated. The user does not see any of that complexity—only the resulting change in the output palette. By combining these controls, one can achieve nuanced effects: for instance, a high warmth ($+0.8$), high intensity ($0.9$) setting might produce a very rich orange-tinted journey even if the anchors were neutral, and enabling loop in that scenario might result in a phased loop that gradually shifts hue on each cycle, as the engine interprets the warm bias as license to drift hue over time. Conversely, a cool bias with low intensity would produce a subtle bluish, low-saturation gradient, and if looped, the engine might simply ping-pong to avoid introducing further hue shifts (keeping the effect mild and consistent). The flexibility of these parameters ensures the engine can be tailored to different design goals while still upholding the core principles of smoothness and perceptual validity.

\section{Output Structuring and Formats} \label{sec:output}

The Color Journey Engine is meant to integrate into real design and development workflows, so it produces outputs in formats that are immediately useful to developers. After computing the palette (the sequence of swatch colours from the first anchor through the last, including any loop extensions if requested), the engine can format this data in several ways:

\begin{itemize}
\item \textbf{Discrete Palette List.} The simplest output is an ordered list of colour values representing the swatches. This can be, for example, a list of hexadecimal colour codes (e.g. \texttt{#RRGGBB}) or an array of RGB triplets in the 0–255 or 0–1 range. This discrete palette explicitly enumerates each colour from the journey in sequence. It is useful for applications like generating a series of colours for a chart, a set of theming colours for UI components, or simply displaying a gradient as a series of swatches. Developers can take this list and directly plug the colours into whatever context needed (CSS styles, canvas drawing commands, etc.). The first element of the list will be the first anchor (unless anchors were nearly identical and collapsed), and the last element will be the final anchor (or possibly a loop-around colour if extended), and in between are the computed intermediate swatches.
\item \textbf{Structured JSON Output.} For programmatic use, the engine can output a JSON structure containing not only the colours but also metadata about the journey. For example, the JSON might look like:
\begin{verbatim}
{
“anchors”: [”#D94141”, “#1E88E5”],
“swatches”: [”#D94141”, “#C85A5C”, “#A37C82”, “#7B9EAB”, “#55BFE0”, “#1E88E5”],
“strategy”: “OKLCH”,
“parameters”: { “warmth”: 0.0, “intensity”: 0.5, “smoothness”: 1.0, “loop”: false }
}
\end{verbatim}
In this example, the JSON indicates two anchors (a reddish and a bluish in hex), the resulting sequence of swatches from start to end (including the anchors themselves as first and last), and some details of how it was generated (strategy and parameter settings). Such a structure allows a developer or a tool to ingest the entire specification of the palette. One could even include the OKLab coordinates or the positions $t$ along the path for each swatch if needed. JSON output is especially useful for pipelines where the palette might be consumed by different systems (for instance, a design token generator or a visualization library) because it’s both human-readable and machine-parseable.
\item \textbf{CSS/Style Exports.} For web design purposes, the engine can output the palette as CSS constructs. One common representation is a CSS linear-gradient string. For example, given the swatches list above, the engine could produce:
\begin{verbatim}
background: linear-gradient(to right,
#D94141 0%, #C85A5C 25%, #A37C82 50%, #7B9EAB 75%, #55BFE0 90%, #1E88E5 100%);
\end{verbatim}
This defines a smooth gradient that uses the computed swatches as colour stops (perhaps distributing them evenly or according to perceptual spacing). If the goal is an actual smooth gradient fill, using the anchors and maybe a few key midpoints might suffice, whereas if one wants a segmented look, each swatch can be a hard stop. Another form of CSS export is to define custom properties (CSS variables) or SCSS variables for each colour: e.g., \texttt{--palette-1: #D94141;} etc., which can then be referenced in a stylesheet. The engine could also output these if an entire design system’s colours are being generated. In addition, formats like SVG gradients or other styling rules could be produced as needed. The key idea is that the output can be directly embedded into front-end code.
\end{itemize}

Regardless of format, the output will reflect any gamut clipping that was done: i.e. all colour values will be valid (e.g. all RGB components between 0 and 255 for 8-bit colour). If the user requested a looped palette with a specific number of swatches, the output list will have exactly that many entries (the engine will have extended appropriately). If no specific count was requested, the output list length is determined by the adaptive algorithm (which depends on anchor distances and $\Delta_{\max}$ as discussed). In the JSON or other rich formats, one can include the actual $\Delta$ values or the number of segments used, if that information is of interest (for instance, to see how many steps the engine inserted between certain anchors, which might be useful for debugging or fine-tuning anchor placement).

In summary, the engine’s output structuring is designed to serve both as a final deliverable (a ready-to-use colour palette for design or implementation) and as a means of verification (communicating what strategy and parameters were applied). This ensures that the “journey” can be seamlessly integrated into the end usage context, whether it be dynamic theming, data visualization, or generative art.

\section{Caller Responsibilities}

The Color Journey Engine automates much of the colour interpolation process, but the calling code or user of the engine has a few responsibilities and considerations to ensure the best results:

\begin{itemize}
\item \textbf{Providing Meaningful Anchors.} The user must supply one or more anchor colours that make sense for the intended palette. While the engine can technically handle anchors that are extremely close together or very far apart in colour, the user should be aware that anchors that are nearly identical may result in redundant output (the engine might collapse them), and anchors that are extremely different (e.g. a very dark color and a very light, highly saturated color) will result in a complex journey. It is advisable to choose anchors that represent the key “waypoints” of the desired colour scheme. If more than 5 anchors are needed conceptually, the user may need to either reconsider the palette or use the engine iteratively (as the design currently focuses on up to 5 anchors for manageability).
\item \textbf{Input Format and Gamut.} Anchors should be provided in a standard colour format (such as sRGB hex codes or RGB triples). The engine assumes sRGB gamut for anchors. If a user somehow provides a colour outside the sRGB gamut (which could happen if using a wider gamut space), the engine will clamp or adjust it upon conversion to OKLab. It’s best if the caller ensures anchor colours are within the intended display gamut to avoid unintended shifts. Also, the user should ensure the anchors are given with correct formatting (e.g. normalized 0–1 floats if using that API, or valid 0–255 integers for RGB). The engine does basic validation, but it’s the caller’s responsibility to not feed completely invalid values.
\item \textbf{Setting Parameters Appropriately.} The stylistic parameters (warmth, intensity, contrast, smoothness, etc.) have default values (usually neutral or mid-range settings that yield a balanced result). The user can override these, but should do so with understanding: e.g. setting intensity to 1.0 will maximize saturation which might not always be desirable (it could push colours to the edge of gamut or make a palette too neon for a subtle design). Similarly, a maximum warmth bias could significantly tint the intermediate colours. The caller should tune these parameters according to the context and perhaps provide UI sliders if this engine is used in a design tool. It’s also their responsibility to ensure they remain in the allowed range (the engine will clamp values outside $[-1,1]$ or [0,1] to the nearest boundary).
\item \textbf{Handling Output Use.} Once the engine returns the palette (in whichever format), it’s up to the caller to actually apply it or present it. For example, if a JSON is returned for a chart library, the developer should extract the colours and assign them to chart series or categories. If a CSS gradient string is returned, the developer needs to insert it into a stylesheet or style attribute. The engine does not automatically modify any design; it only provides the data. The user should also be mindful of context: even though the palette is perceptually smooth, certain use cases (like text on these colours) might require additional steps. For instance, if using the palette for data visualization, adjacent colors in the palette are distinguishable by design (due to $\Delta_{\min}$), but if using them for something like sequential backgrounds behind text, the user should ensure the text remains legible (the engine does not enforce contrast between text and background, for example). In summary, the engine guarantees internal consistency of the palette, but the external usage context can impose further requirements that the user must handle (like contrast against some reference or thematic consistency with branding guidelines).
\item \textbf{Iterative Refinement.} The caller should be prepared to adjust anchors or parameters and rerun the engine if the first result isn’t ideal. Because the engine’s output can depend sensitively on anchor placement and parameter values, the user might try a few iterations. For example, if the palette came out too dull in the middle, the user could either increase the intensity parameter or even insert an intermediate anchor of a desired hue to guide the journey. The engine is a tool that operates on the given inputs; providing good inputs is part of the user’s responsibility. In a developer workflow, this might mean writing tests or visual checks for the output palette and adjusting accordingly.
\item \textbf{Performance Considerations.} For most uses, the engine is fast (a few anchors and at most tens of swatches). However, if a user requests an extremely high number of swatches (say, hundreds for a very fine gradient or a long looped sequence), they should consider the performance and memory implications. The engine will do the work, but the caller should avoid unnecessarily large outputs. Also, if integrating into a real-time system (like interactive palette tuning), the caller might throttle calls to the engine or use caching for repeated inputs. Essentially, typical optimization and integration concerns remain with the developer using this engine.
\end{itemize}

By adhering to these responsibilities, the user of the Color Journey Engine can ensure that the generated palettes meet their needs and are applied correctly. The engine is designed to be robust (e.g. it won’t crash on bad input; it will clamp or adjust and return something), but the quality and relevance of the output is a shared responsibility—good input and proper use lead to the best results. In return, the engine greatly reduces the burden on the developer/designer by handling the tricky parts of colour interpolation and palette generation in a perceptually grounded way.

\section{Conclusion}

We have presented a comprehensive design for the Color Journey Engine that combines perceptual colour science with adaptive sampling and flexible interpolation strategies. The engine operates entirely in the OKLab space, ensuring that Euclidean distances correspond closely to perceived colour differences ￼. It enforces a minimum and maximum distance between consecutive swatches, thereby dynamically determining the number of intermediate colours required without the user having to specify the count. The system supports up to five subdivision segments between any two anchors, guaranteeing visual smoothness while keeping palettes concise. A variety of interpolation strategies—linear in OKLab, chroma-preserving OKLCH, two-phase lightness-first or hue-first approaches, neutral pivots for extreme transitions, and several looping topologies—allow users to tailor the character of the colour journey to their specific needs. Internal mechanisms such as automatic gamut clamping and hue wrap-around maintain the validity and smoothness of the colours under the hood so that users do not encounter impossible colours or sudden hue flips.

Through high-level parameters (warmth, intensity, contrast, smoothness, and looping control), users influence the journey in intuitive terms. These map behind the scenes to mathematical adjustments (like nudging Bézier control points or picking alternative path algorithms), which the engine executes to produce the desired effect. The result is a tool that hides the complexity of color conversion and interpolation behind a simple interface, yet produces mathematically grounded and perceptually coherent palettes. We believe such a system is valuable in interface design, data visualization, and artistic applications where controlled colour transitions are essential. Reproducibility of results is ensured, so palettes can be depended upon in production and shared across platforms. The design emphasizes both flexibility and consistency: developers can explore creative options without sacrificing the reliability of the outcome. Future work might extend the engine to handle more exotic colour spaces (for high dynamic range, for example) or to incorporate temporal dynamics (for animated colour transitions), but the foundation laid out here provides a solid, extensible core for “journeying” through colour space in a principled way.

\end{document}

The Color Journey Engine: Conceptual Design and Perceptual Modeling

Introduction

The Color Journey Engine is a framework for generating smooth, perceptually coherent sequences of colors (or color journeys) under a variety of configurable constraints. It enables developers to define a path through color space that transitions between one or more specified key colors (called anchors) while controlling perceptual attributes such as lightness, chroma (colorfulness), warmth (hue bias), vibrancy, and contrast. The engine’s design emphasizes a high-level, abstract description of color transitions: it operates in a perceptually uniform color space to ensure smooth visual change, applies formal mathematical reasoning to construct color paths, and offers dynamic controls for biasing the journey’s behavior without exposing low-level implementation details. This paper presents a detailed technical overview of the Color Journey Engine’s conceptual design and algorithms, including its use of the OKLab perceptual color model, multi-anchor interpolation logic, dynamic parameter influences, looping strategies for continuous or reversible color sequences, methods for introducing pseudo-random variation deterministically, and mechanisms for gamut-awareness and constraint enforcement. We focus on the why and how at a conceptual level – using equations and formal descriptions to explain the engine’s behavior – while avoiding any specific code or implementation-level particulars.

Design Principles

The Color Journey Engine is guided by several key design principles that ensure the generated color sequences are perceptually smooth, configurable, and reproducible:
	•	Perceptual Uniformity: Color interpolation and distance calculations are done in a perceptually uniform space so that equal steps in the journey correspond to equal perceived differences ￼. By using a modern perceptual model (OKLab), the engine avoids the artifacts of naive RGB or HSV interpolation where intermediate colors can appear unsaturated or unexpected (e.g. blending red and cyan in RGB yields a dull gray mid-point ￼). This ensures transitions that look smooth to the human eye, as changes in lightness, chroma, or hue are perceived as uniform as possible.
	•	High-Level Configurability: The engine provides abstract dynamic control parameters – such as lightness, chroma, warmth, vibrancy, and contrast – that allow the shape of the color journey to be adjusted without manipulating low-level color values directly. These parameters introduce perceptual biases or emphasis (for example, making the sequence gradually lighten, or pass through warmer hues) in a controlled manner. Users can thus easily tune the “feel” of the color progression (e.g. softer vs. high-contrast, cooler vs. warmer) by adjusting a few intuitive settings.
	•	Anchor-Based Modularity: The journey is defined by up to m anchor colors (with 1 ≤ m ≤ 5) which act as fixed keyframes in color space. This modular design means the overall path is broken into segments between anchors, making complex multi-stage color progressions easier to manage. Each anchor is guaranteed to appear in the final sequence, and the path construction logic ensures a smooth traversal through these anchors in order. This principle enforces a structure on the journey: anchors serve as waypoints that the journey must hit, dividing a complex transition into simpler sub-transitions.
	•	Looping & Continuity: The engine supports different curve and loop strategies to determine how the color path begins, ends, and possibly repeats. It can produce open journeys (a single transition from start to end anchor), closed loops (cyclic color palettes that return to the starting color), as well as specialized looping behaviors like ping-pong (the path reverses direction at the ends for back-and-forth oscillation) and Möbius loops (a path with a half-twist, requiring two iterations to return to the start). These options allow the output to be used in scenarios like seamless cycling animations or continuous palettes with no boundary between end and start.
	•	Dynamic Variation with Determinism: The engine can introduce controlled randomness into the journey construction – e.g. subtle perturbations or alternate routes in color space – to generate variations of a color sequence. Crucially, this is done with pseudo-random determinism: a user-provided seed ensures that the same input (including seed) always yields the same color sequence, while different seeds produce distinct variations. This approach enables exploration of different palettes or transitions in a reproducible way, marrying the benefits of randomness (variety, avoiding uniform repetition) with the need for consistency in a development or design workflow.
	•	Gamut Awareness & Constraint Enforcement: All color computations are mindful of the target display gamut and any design constraints. Because the engine operates in an expansive perceptual space (OKLab) that is not limited to displayable colors, it must enforce that final output colors lie within the intended output gamut (typically sRGB) ￼. The engine includes a gamut-mapping step to ensure no calculated color falls outside the range of real colors that screens can show; if an intermediate color is out-of-gamut, it is projected or adjusted to a suitable in-gamut color ￼. Other constraints (for example, keeping a minimum contrast between successive colors, or locking an anchor exactly to a given value) are also honored by adjusting the journey or clamping values as needed. These safeguards guarantee that the output is not only theoretically well-behaved but also practical for real-world use (e.g. no invalid colors, no violation of user-specified limits).
	•	Reproducibility and Purity: The engine’s behavior is deterministic given the same inputs (including anchors, parameter settings, loop mode, and random seed). It does not rely on any hidden state or external context, which is critical for debugging and consistency. This pure functional design means that developers can trust the engine to produce the same color journey every time for a given configuration, and differences will only arise when inputs are intentionally changed. It simplifies testing and integration into larger systems (such as design token generators or generative art tools) because runs are repeatable and free of side effects.

These design principles ensure that the Color Journey Engine outputs sequences of colors that are perceptually smooth, flexibly tuned to creative needs, and reliable across repeated uses. In the following sections, we delve deeper into the theoretical foundation and each major component of the engine’s logic, including the perceptual color model, anchor-based path construction, dynamic parameter influences, looping strategy implementations, controlled variation, output format, and responsibility boundaries.

Scope and Exclusions

The Color Journey Engine is intended as a specialized tool for generating one-dimensional color sequences (palettes or gradients) under the aforementioned design principles. To clarify its scope, we enumerate what the engine does and does not cover:
	•	In-Scope:
	•	Perceptual Color Sequences: The core purpose is to create ordered lists of color swatches that transition smoothly in perceptual terms. The engine supports up to five anchor colors to define complex transitions. It covers both simple two-color interpolations and multi-anchor journeys comprising several color segments.
	•	Dynamic Parameter Adjustments: The engine allows tweaking high-level visual characteristics (lightness trend, saturation levels, hue biases, etc.) through its dynamic controls. These influences are within scope insofar as they shape the color outputs; the engine handles their interpretation and integration into the color computations.
	•	Loop Configurations: The engine can output both finite sequences (open journeys) and cyclic sequences (closed loops or ping-pong arrangements) based on user choice. Ensuring continuity at the loop boundary (for closed or ping-pong modes) is within scope, so that repeating the sequence does not create a perceivable jump in color.
	•	Output Formats: The engine produces output in developer-friendly formats, primarily an array of color values ready to use in code. Typical output might be in CSS-compatible strings (hex #RRGGBB, rgb(), hsl(), or newer CSS Color Level 4 formats like lab()/oklab()), or as structured data that can be easily converted to such formats. The engine ensures the output colors respect the sRGB gamut for compatibility with web and digital displays.
	•	Out of Scope / Exclusions:
	•	Code Implementation Details: The engine’s internal code, specific data structures, or performance optimization techniques are not part of this high-level description. We abstract away all implementation-level specifics – such as how random numbers are generated internally, how color conversion algorithms are coded, or how memory is managed – focusing only on the conceptual and mathematical logic.
	•	Image-Wide Color Adjustments: The engine is not an image filter or color grading tool for photographs. It does not analyze or adjust colors in a full image or design composition. Its scope is confined to producing a stand-alone sequence of color values. Integrating these values into UI components, graphics, or images is the responsibility of the caller (the engine treats colors in isolation, not knowing how they will be applied to actual content).
	•	Beyond 5 Anchors: The engine deliberately limits the number of anchors to a maximum of five to keep the model manageable and the journey understandable. Complex workflows requiring more than 5 distinct key colors would need to be handled by chaining multiple journey outputs or by user pre-processing (e.g., choosing intermediate anchors that themselves represent groups of colors). The engine does not natively support arbitrarily long anchor lists in one go.
	•	Automatic Color Semantics: The engine does not incorporate high-level semantic understanding of colors (for example, it doesn’t “know” that certain colors are considered warm vs. cool beyond their numeric hue, nor does it ensure a palette matches a theme like “sunset” or “ocean” without user guidance). All influences on warmth, vibrancy, etc., are numeric and perceptual, not symbolic. It also does not perform tasks like naming colors or ensuring that colors meet external criteria like brand guidelines or accessibility standards – those considerations must be applied by the user, possibly by adjusting anchors or parameters or by post-filtering the results.
	•	Physical Accuracy: While the engine uses perceptual modeling for human visual relevance, it is not a physics-based color simulation. It does not account for illumination conditions, material properties, or other situational context that might alter color appearance. It assumes a standard viewing condition (like typical screen display in standard lighting) and a standard observer. Specialized use-cases like high-dynamic-range displays, unusual lighting adaptation, or printer-specific gamuts are beyond the default scope (though the conceptual framework could be extended with different color space settings or calibration if needed).

By clearly defining its scope, the Color Journey Engine maintains focus on delivering high-quality perceptual color transitions without overreaching into areas best handled by other tools or by developer judgment. Next, we discuss the perceptual foundation of the engine – the OKLab color model – which is central to achieving the uniform and predictable color behavior that falls within the engine’s scope.

Perceptual Color Model: OKLab

At the heart of the Color Journey Engine’s approach is the use of a perceptually uniform color space to perform all color calculations. We adopt the OKLab color model as our working space for color manipulation, due to its balance of perceptual fidelity and computational simplicity ￼ ￼. In this section, we outline the OKLab model and how it underpins the engine’s color interpolation and distance computations.

Rationale for a Perceptual Color Space

Human vision perceives differences in color nonlinearly: a simple linear blend of RGB values does not correspond to a linear perceptual transition. For example, interpolating between saturated blue and yellow in raw RGB can produce washed-out grays or unexpected hues in the middle, because the intermediate points travel through an unsaturated region of color space ￼. Similarly, equal numerical changes in hue or lightness in naive HSV/HSL models often result in uneven perceptual changes (some hues appear brighter or more intense than others for the same numeric step ￼). To address this, scientists have developed perceptually uniform color spaces where Euclidean distances correspond more closely to perceived color differences. In such spaces, moving a given distance in any direction produces a change that observers judge to be of similar magnitude ￼.

OKLab is a modern perceptual color space designed to predict human color perception (lightness, chroma, and hue differences) accurately while being computationally efficient. Unlike older models such as CIELAB from the 1970s, OKLab achieves improved perceptual uniformity for both small and large color differences, and avoids some artifacts of CIELAB (which, for instance, can become less reliable for very dark or saturated colors ￼). In comparison to other advanced perceptual models (like CAM16-UCS or JzAzBz), OKLab is simpler to implement (it has an analytical forward and inverse transform) yet still “ensures that equal steps in its coordinate space correspond to equal steps in perceived colour difference” ￼. In other words, a linear interpolation in OKLab tends to look linear to the eye, yielding smooth, natural-looking colour scales ￼. Moreover, OKLab is well-behaved numerically: it’s roughly linear in complexity (making it fast) and does not produce imaginary color components or require iterative solvers, etc. – important considerations for an engine meant to be used in real-time or design tooling contexts ￼.

By building on a perceptual color space, the Color Journey Engine can reliably create gradients and palettes that avoid unintended dips in intensity or shifts in hue. This choice of model is a foundational design decision: it offloads much of the work of “evening out” the color transitions to the properties of the space itself, so that the engine’s higher-level logic can operate on nearly linear behavior in perceptual terms. The next subsections describe the OKLab model in more detail and how we use it in the journey computations.

OKLab Coordinates and Perceptual Dimensions

OKLab represents colors using three coordinates, which we will denote as L, a, and b (analogous to CIELAB’s L*a*b* axes, though derived differently). The components are:
	•	L – the lightness dimension, where 0 represents perceptual black and 1 (or 100%) represents the brightest white (under a reference white illumination). Lightness correlates with how light or dark a color appears. Equal differences in L aim to correspond to equal steps in perceived brightness.
	•	a – one opponent color dimension (roughly green–red axis in perception). Positive a values correspond to colors with a magenta/reddish tint; negative a values correspond to colors with a greenish tint. Zero a is achromatic along that axis.
	•	b – the second opponent color dimension (roughly blue–yellow axis). Positive b corresponds to yellowish tints; negative b corresponds to bluish tints. Zero b is achromatic along this axis.

Crucially, the L, a, b axes in OKLab are designed to be approximately orthogonal in perception: altering L alone (up or down) should not significantly change the perceived hue or chroma of the color; altering a or b primarily changes hue or chroma without affecting perceived lightness ￼ ￼. This orthogonality means we can independently reason about lightness dynamics versus chromatic dynamics in the journey. The engine takes advantage of this separation: for instance, one can brighten or darken the color sequence (change L values along the path) without accidentally causing odd hue shifts or saturation changes, which would not be true in RGB or other non-uniform spaces ￼.

Mathematically, OKLab is defined via a conversion from the CIE XYZ color space (which is tied to physical measurements of color). The transform involves a linear matrix to convert XYZ to an LMS space, a nonlinearity (taking cube-roots of the LMS components), and another linear combination to yield L, a, b ￼. While the full formula is beyond our scope here (and not needed for using the engine), we note one key property: the Euclidean distance in OKLab,

\Delta E_{\mathrm{OKLab}} = \sqrt{(L_2 - L_1)^2 + (a_2 - a_1)^2 + (b_2 - b_1)^2},

is designed to correlate with perceived color difference (a property verified against datasets of human vision experiments ￼ ￼). Thus, the engine can use simple linear interpolation and this Euclidean metric internally to ensure uniformity. For example, if we want N intermediate colors between two anchors such that each adjacent pair looks equidistant, we can space them evenly along the straight line segment connecting the anchor points in (L,a,b) space – this will produce a series of colors that, ideally, the human eye perceives as evenly stepping from the first color to the second. OKLab’s uniformity makes such straightforward approaches effective ￼.

In addition to the Cartesian coordinates (L, a, b), it is often useful to express OKLab in polar form for certain operations. We define OKLCh (analogous to LCh in CIELAB) where:
	•	L is the same lightness as in OKLab,
	•	C (chroma) = √(a² + b²), the distance from the neutral axis, representing color intensity or saturation,
	•	h (hue angle) = atan2(b, a), the angle around the a–b plane, representing the hue family (red, yellow, green, blue, etc.).

This cylindrical form is convenient because parameters like “warmth” naturally relate to hue h, and “vibrancy” relates to chroma C. For example, colors with high hue angle around 0° or 360° might be reds (warm), around 90° yellows (warm), 180° greens (cooler), 240° blues (cool), etc., so a warmth bias might entail shifting hue values toward the warm side of the circle (e.g. toward the reds/yellows). Meanwhile, a vibrancy boost might mean increasing the chroma C of all colors (making them more saturated or vivid), and a contrast change might involve increasing the range of L (making darks darker and lights lighter). The OKLCh representation allows us to conceptualize and implement such adjustments cleanly: for instance, by working in polar coordinates we can change the hue smoothly (taking the shortest path around the circle or a specified direction), and scale or offset C to adjust saturation.

To summarize, the Color Journey Engine converts all input colors (anchors) to OKLab coordinates for internal processing. All interpolations between anchors, dynamic adjustments, and variation perturbations occur in this perceptually uniform space. Only after the final colors are computed in OKLab do we convert them to the desired output color space (usually sRGB for CSS/Hex output). By doing the heavy lifting in OKLab/OKLCh, the engine ensures that the mathematical logic aligns with visual intuition: a straight line or smooth curve in this space yields a visually smooth gradient, and simple function tweaks correspond to intuitive visual changes.

Citing an example: if we interpolate from a pure blue anchor to a pure yellow anchor in OKLab, the intermediate colors will progress through desaturated grayish blue to neutral gray to grayish yellow smoothly, without an unexpected detour into a bright green (which could happen in naive RGB interpolation) ￼. In OKLab, that path’s mid-point is a dull gray (since blue and yellow are complementary and cancel out chroma) but importantly the lightness and chroma along the path are perceived as continuous and monotonic – no strange darkening or overshooting in saturation occurs. The result is a gentle transition that a viewer would see as a consistent fade from blue to yellow, which is exactly the intent.

Having established the perceptual color model and coordinates, we now turn to how the engine constructs a journey through this space given a set of anchors and dynamic parameters. We will first discuss the general model of anchor-based journeys, then detail how dynamic biases and looping come into play.

Anchor-Based Journey Modeling

The anchors are user-defined key colors that serve as fixed points the color journey must pass through. They define the overall skeleton of the color path. Formally, let there be m anchors, with 1 ≤ m ≤ 5, given in a specific sequence: A_1, A_2, ..., A_m. Each anchor A_i is a color specified by the user (for example, as a hex code or RGB tuple), which the engine internally converts to OKLab coordinates (L_i, a_i, b_i). The engine will construct a continuous path J(t) in the OKLab color space such that:
	•	At the start of the journey (parameter t = 0), J(0) = A_1 (the first anchor’s color).
	•	At intermediate milestones, J(t_i) = A_i for some increasing sequence of parameter values 0 = t_1 < t_2 < \dots < t_m = 1 – typically we assign these milestones evenly or proportionally along the unit interval. In simple cases with uniform spacing, t_i = \frac{i-1}{m-1} for anchors 1 through m. Thus J(t_{m}) = A_m at t=1.
	•	Between each pair of successive anchors A_i and A_{i+1}, the function J(t) is defined to smoothly transition from A_i to A_{i+1}, influenced by the dynamic parameters (which can bend or bias the interpolation, as described later). The path is continuous in OKLab space, and ideally differentiable (no abrupt jumps) unless specifically intended (for example, a ping-pong reversal might introduce a cusp if not handled carefully, but ordinarily even that is smoothed).

In essence, the journey J(t) is a piecewise-defined curve through OKLab, with each segment connecting one anchor to the next. Because OKLab is approximately Euclidean-perceptual, a straightforward approach is to construct each segment as a parametric curve J_i(t) for t_i \le t \le t_{i+1} that satisfies J_i(t_i) = A_i and J_i(t_{i+1}) = A_{i+1}. The simplest such curve is the linear interpolation (Lerp) between the two anchors in OKLab:

J_{\text{linear},i}(t) = A_i + \frac{t - t_i}{\,t_{i+1} - t_i\,} \big( A_{i+1} - A_i \big),

for t \in [t_i, t_{i+1}]. This yields a straight-line segment in Lab space, which as noted tends to look smooth due to OKLab’s uniformity. However, the engine often modifies this basic linear path according to dynamic parameters (creating a curve in color space rather than a straight line) – we will address these modifications shortly.

First, let us consider special cases for the number of anchors:

Single-Anchor Journeys (m = 1)

If only one anchor A_1 is provided, the notion of a “journey” might seem degenerate – there is no second color to transition to. In this case, the engine interprets the task as creating a self-contained color loop around that single anchor. Essentially, with one anchor the journey is designed to start at the color and eventually return to it, producing a closed palette centered on the anchor color. The engine will generate a sequence of colors that deviate from the anchor in various dimensions (lightness, hue, etc.) and come back, forming a loop in color space.

For example, suppose A_1 is a specific shade of blue. A single-anchor journey might produce a set of colors that vary that blue in subtle ways – perhaps slightly lighter and slightly darker variants, or a cycle that shifts the hue to a neighboring tint (like a purplish blue and a greenish blue) and then returns to the original blue. The idea is to create a harmonious set of related colors forming a closed curve through the anchor. Because there is only one anchor, this journey’s shape is heavily influenced by loop settings and dynamics: by default, the engine will treat this as a closed loop (since open journey with one point is trivial). It might create, for instance, a loop that leaves A_1 in a particular direction in Lab space (according to bias parameters), then swings around through a different hue or lightness and comes back to A_1 from another side. One could imagine it as drawing a small ellipse or circle around A_1 in the Lab color space – the size and orientation of that ellipse determined by the dynamic parameters (e.g., a loop that goes through lighter and darker variations would primarily vary L, whereas a loop that explores warmer and cooler tints would primarily vary the a/b coordinates). We’ll detail in Looping and Path Closure how exactly a closed loop is constructed, but suffice it to say that the engine ensures J(0) = J(1) = A_1 for a one-anchor journey, producing a cyclic palette anchored on that color.

In practical terms, a one-anchor mode is useful for generating a monochromatic palette with some variation, or an animation that cycles out from and back to a single color (like a pulsating effect or a rotating hue around a base color). The anchor remains the centerpiece, and the other colors provide context or states around it.

Multi-Anchor Journeys (m ≥ 2)

With multiple anchors, the engine will construct a multi-segment path. If anchors are A_1, A_2, ..., A_m in sequence, the journey consists of segment 1 from A_1 to A_2, then segment 2 from A_2 to A_3, and so on until segment m-1 from A_{m-1} to A_m. Each segment is influenced by the dynamic parameters and is computed in OKLab space to ensure perceptual smoothness between those two anchor colors.

By default, the parameterization t can be taken as proportional to cumulative path length or simply evenly split among segments. A simple choice is to divide the unit interval into equal parts for each segment: for m anchors, one would set t_i = \frac{i-1}{m-1} (for i = 1…m). This means the travel from one anchor to the next occupies \frac{1}{m-1} of the total parameter range. The engine can also weight segments differently if desired – for example, if two anchors are very close in Lab distance while the next pair is far apart, one might allocate proportionally less t range to the short segment so that the visual progression speed (in terms of ΔE per Δt) is more uniform. However, by default the engine assumes anchors are placed with intent and uses equal t-spacing unless a specific timing weight is provided for anchors.

At each anchor beyond the first, continuity conditions are enforced. The journey goes through A_i exactly at the segment boundary. If a simple linear approach were used for each segment independently, J(t) would already be continuous at anchors. However, there could be a sharp turn in the path at an interior anchor (like an angle if the incoming and outgoing linear segments are not collinear). The engine can optionally smooth out such corners using curve techniques (e.g., by constructing a spline through the anchors rather than straight segments). One common strategy is to use a cubic interpolating spline (like a Catmull–Rom spline in Lab space) which guarantees J(t_i) = A_i for all anchors and has continuous first derivatives at those points, resulting in a smooth curvilinear path rather than a piecewise linear one.

Anchor Smoothing: If smoothing is enabled, for each interior anchor A_i (with i not 1 or m), we adjust the path near that anchor so that the direction of approach equals the direction of departure, avoiding a sharp corner. This can be achieved by defining intermediate control points on either side of the anchor that are collinear with the incoming/outgoing directions. The specific method is beyond the high-level description, but conceptually the engine might create a small “rounding” of the corner in Lab space. Smoothing ensures that dynamic adjustments (like continuous changes in lightness) don’t reset abruptly at an anchor but rather flow through it. For example, if anchor A_2 is much lighter than both A_1 and A_3, a naive approach could yield a sudden change in the lightness gradient at A_2; a smooth interpolation will distribute that lightness peak more gently around A_2, making the brightness change feel more gradual through that point.

On the other hand, if an anchor is meant to be a deliberate sharp change (perhaps the user wants a noticeable shift at that color), the engine can allow it by not smoothing or by applying minimal smoothing. The decision to smooth can be automatic or user-specified as part of journey configuration. By default, for natural-looking palettes, a moderate smoothing is applied so that the sequence has no visual jolts at anchor boundaries.

In any case, the multi-anchor journey guarantees that each anchor’s exact color value will appear in the output sequence at the appropriate position. This is an important constraint: the user’s anchors are treated as ground truth points that the engine should not alter (except possibly slight adjustments if an anchor is out of gamut, in which case it might be moved to the nearest in-gamut color). The dynamic parameters can influence the path between anchors, but they do not change the anchor colors themselves. Anchors act as fixed boundary conditions for the segments.

Now that we understand how anchors define the basic path segments, we will examine how the journey construction logic works in detail, incorporating the dynamic controls and loop strategies into the formation of J(t).

Journey Construction Logic

The process of constructing the color journey can be described as an algorithm operating on the anchor points in OKLab space and the various configuration parameters. At a high level, the algorithm proceeds as follows:
	1.	Input Processing: The engine receives the list of anchor colors A_1 \dots A_m (m anchors, 1 ≤ m ≤ 5) along with the configuration settings: dynamic parameter values (desired biases for lightness, chroma, warmth, etc.), the looping mode (open, closed, ping-pong, or Möbius), a random seed (for variation), and any additional constraints (like ensure minimum contrast, lock certain attributes, etc.). Each anchor A_i is immediately converted from its input representation (e.g. hex or RGB) into OKLab coordinates (L_i, a_i, b_i) for internal use. If needed, a corresponding polar form (L_i, C_i, h_i) is also computed for convenience.
	2.	Parametrization of the Path: We assign parameter values along the journey for each anchor. For example, for an open journey from A_1 to A_m, we set t_1 = 0 at A_1 and t_m = 1 at A_m. Intermediate anchors get intermediate t values as discussed (uniform by default: t_i = \frac{i-1}{m-1}). For a closed journey, we might conceptually also assign t_{m+1}=1 to the return to A_1 (which is the same color as A_1), or handle it separately in the loop logic. The parameter t acts as a pseudo-time or progression fraction through the journey.
	3.	Base Trajectory Definition: The engine next defines a preliminary trajectory through the anchors. If no dynamic biases were specified and no variation, this base trajectory could simply be the piecewise linear interpolation through A_1 \dots A_m in Lab space (or a smooth spline through them). Let’s call this preliminary path J_0(t). For each segment between A_i and A_{i+1}, we have a vector difference \Delta_{i} = A_{i+1} - A_i = (L_{i+1}-L_i,\; a_{i+1}-a_i,\; b_{i+1}-b_i) in Lab coordinates. The linear path segment would be J_{0,i}(t) = A_i + \alpha(t) \Delta_i for t \in [t_i, t_{i+1}] with \alpha(t) = \frac{t - t_i}{t_{i+1}-t_i}. If using spline interpolation, J_0(t) might be given implicitly by polynomial pieces that ensure continuity up to first or second derivative at anchors. The key is that J_0 is a deterministic geometric path through the anchor points, before any fancy adjustments. It respects anchor positions but not yet dynamic parameter preferences (those will modulate it next).
	4.	Applying Dynamic Parameter Biases: The engine now adjusts the path J_0(t) to incorporate the dynamics – the user’s desired biases in lightness, chroma, hue direction, etc. This is done by modifying the parametric equations for the L, a, b (or L, C, h) components of the journey as functions of t. We introduce functions or factors for each relevant attribute:
	•	A lightness shaping function f_L(t) that alters the distribution of L along the path.
	•	A chroma shaping function f_C(t) for the C (chroma) component along the path.
	•	A hue bias or warmth function f_h(t) that can alter the route in hue space.
	•	Perhaps others for vibrancy or contrast as needed (some of these might overlap with the above or be implemented by combinations of them).
These functions are derived from the user’s dynamic parameter values. For instance, if the user sets a high lightness contrast or lightness dynamics value, f_L(t) might be a curve that exaggerates the lightness range – say, pushing the darkest parts of the journey even darker and the brightest parts even brighter relative to the linear baseline. One simple way to implement this is by using an easing curve. For example, to emphasize contrast, we might use an S-curve (sigmoidal) for lightness: f_L(\alpha) = \sigma(\alpha) where \sigma is a sigmoid that spends more time near 0 and 1. A concrete example is f_L(\alpha) = \alpha^p / \big(\alpha^p + (1-\alpha)^p\big) for some exponent p: if p > 1, this yields a curve that is below the diagonal at midpoints and steep near the ends, meaning the interpolation will stay near the start lightness longer then rapidly move to the end lightness – effectively high contrast, with darker darks and lighter lights. Conversely, if p < 1, it produces a convex curve (above the diagonal) that biases the lightness toward the middle values (lower contrast, more evenly intermediate). Setting p = 1 gives f_L(\alpha) = \alpha, the neutral linear case ￼. The engine might set p based on a user’s “contrast” slider. Alternatively, it might use a predefined ease-in/ease-out polynomial (like f_L(\alpha) = 3\alpha^2 - 2\alpha^3 for a smooth ease-in-out) depending on whether the user wants a gentle or strong bias. The specifics can vary, but the principle is that f_L reshapes how L progresses between anchors. Instead of L changing uniformly, it might pause and then change quickly, or vice versa, according to the dynamic setting.
Similarly, for chroma, f_C(t) might be used to either desaturate or boost saturation at certain points. If the user desires a vibrant middle, f_C could be >1 at mid t (meaning we increase chroma beyond the linear mix) and =1 at the ends (so anchors’ chroma are respected). This could be achieved by temporarily increasing the a and b components’ spread: for example, if C_{lin}(t) is the chroma of the linear interpolation at t, we could target a modified chroma C(t) = C_{lin}(t) * g(\alpha) where g(\alpha) is an adjustment curve (maybe similar in shape to earlier, or something like a bell curve if one wants just a boost in the middle). The engine would then adjust the a and b coordinates proportionally to reach that new chroma while keeping the same hue angle h. Essentially it radially pulls points outwards or inwards in the a–b plane. A vibrancy parameter might be implemented exactly like this: vibrancy > 1 means push chroma higher for intermediate colors (unless already at max gamut), vibrancy < 1 means keep the palette more muted than a straight interpolation.
The warmth bias is implemented by affecting the hue path. Normally, to interpolate hues, the engine would go the shortest way around the hue circle from one anchor’s hue to the next. A warmth bias could override this by deliberately going the longer way round if that path passes through warmer hues. For example, say A_1 is purple (hue ~280°) and A_2 is green (hue ~140°); the direct shortest path in hue would go backward (downward) through blue (~240°) to green, staying in the cool region. A positive warmth bias might tell the engine to go forward in hue from 280° up to say 400° (which modulo 360 is 40°) and continue to 140°, effectively looping through red/yellow (warm region) to get to green. This yields a different set of intermediate colors (purple -> magenta -> red -> orange -> yellow -> chartreuse -> green) which are overall warmer in cast than the direct purple->blue->green path. We formalize this by choosing the sign of hue difference based on the bias sign: the engine will add 360° to the shorter arc or to the longer arc depending on what the user wants. In general, let the raw hue difference be \Delta h = h_{i+1} - h_i (normalized to –180° < Δh ≤ 180° for shortest path). If warm bias is zero, we use Δh as is (shortest path). If warm bias is positive, we might choose the positive direction around the circle regardless of which is shorter (i.e., if Δh was –100°, meaning go clockwise 100°, instead we go counter-clockwise 260° because that passes through the warm side). If warm bias is negative (preferring cool), we might do the opposite. The magnitude of the bias could even control how strongly this preference is applied (for slight biases, possibly we choose a path that maybe goes out of the way a bit toward warm but not fully the long way – that would require an intermediate anchor insertion or a curve that bends toward a warm hue mid-way then corrects back, which is a more complex behavior). For simplicity, the engine might treat warmth bias as a binary choice of which directional path to take in hue interpolation – yielding either a warmer or cooler arc between anchors.
Lastly, contrast as a dynamic parameter can have multiple interpretations. A global contrast setting could scale the overall lightness range of the entire journey. For instance, if anchors do not use the full 0–1 range of L, a high contrast setting might spread them out: the darkest color in the journey is made a bit darker and the lightest a bit lighter (assuming it doesn’t violate gamut or anchor fixity). If anchors are fixed and already at some contrast, the engine can’t exceed anchor values without altering them, so in that case it might only adjust intermediate points: high contrast might cluster intermediate colors toward the low or high end of L rather than in the middle. In essence, it would be similar to the f_L function discussed, just globally affecting the shape. Another aspect of contrast is local contrast – ensuring each consecutive color has a minimum difference. The engine can enforce a minimum ΔE between steps: if the dynamic “contrast” is set high, it might reduce the number of output steps or adjust their spacing so that no two adjacent colors are too similar. This bleeds into the realm of output sampling more than path shape, but it’s worth noting: with a high contrast setting, the journey might skip very subtle transitional colors and only output the more distinct key tones. Conversely, a low contrast (or high smoothness) setting could mean the engine tries to keep differences very small, perhaps increasing the count of steps or compressing differences in some dimensions to avoid any big jumps.
In summary, at this step the engine transforms the base path J_0(t) into a biased path J_{\text{biased}}(t) by applying these functions. Formally, we can express something like:
J_{\text{biased}}(t) = \Big(L_i + (L_{i+1}-L_i) \cdot f_L(\alpha),\quad
a_i + (a_{i+1}-a_i) \cdot f_{ab}(\alpha),\quad
b_i + (b_{i+1}-b_i) \cdot f_{ab}(\alpha)\Big),
for t = t_i + \alpha(t_{i+1}-t_i) in [t_i, t_{i+1}], where f_{ab}(\alpha) is an effective function for the chromatic part that encapsulates both chroma and hue adjustments. In practice, we might separate it into magnitude and direction: we decide a target hue path (with warmth bias) and a chroma profile. The a and b components are then reconstructed from those. For example, we compute a hue h(\alpha) that rotates from h_i to h_{i+1} following the chosen arc (maybe linearly in angle or eased if needed), and a chroma C(\alpha) = C_{lin}(\alpha) \cdot f_C(\alpha). Then a(\alpha) = C(\alpha)\cos h(\alpha),\; b(\alpha) = C(\alpha)\sin h(\alpha). Meanwhile L(\alpha) = L_i + (L_{i+1}-L_i)\cdot f_L(\alpha). This yields the biased Lab coordinates.
	5.	Looping and Path Closure: Depending on the loop mode, additional steps are taken. If the journey is open (default for m ≥ 2 unless specified otherwise), no special action is needed – the path runs from A_1 at t=0 to A_m at t=1 and stops. If the journey is closed, the engine must ensure that the path smoothly connects back to A_1 after t=1. One way to handle this is to effectively have another segment from A_m back to A_1 (closing the polygon) and apply similar interpolation logic for that segment. In doing so, we treat A_1 as identical to A_{m+1} and create the segment from t=1 to t=1+ \frac{1}{m-1} (if we extend t beyond 1). Then we can conceptually reparameterize t back to [0,1] for output or simply note that the output is cyclic. If smoothing is used, we also ensure continuity at A_1/A_{m+1}; essentially the first and last segments have matching derivatives at that anchor. The result is a closed loop in color space. The engine might output the colors along this closed path such that the last color in the array is very close or equal to the first color, allowing a seamless wrap-around. In practice, if an array of swatches is produced for a closed loop, the last swatch can be omitted (since it would be duplicating the first), or included if needed for completeness, but the key is the continuity.
For ping-pong mode, the engine will construct the journey from A_1 to A_m as normal (open path), and then append a reverse journey from A_m back to A_1. The reverse journey is essentially the mirror image: all intermediate colors traversed in the forward direction are traversed again in reverse order. This ensures that if the sequence is played repeatedly (forward then backward), the transition at the endpoints is smooth. In terms of output, a ping-pong sequence might list A_1, ..., A_m, ..., A_1. Typically, A_m would appear at the “turnaround” point and A_1 would appear at both ends. To avoid a double repetition of endpoints when looping, the engine might output A_1, A_2, ..., A_{m-1}, A_m, A_{m-1}, ..., A_2, A_1. Or it could output the forward sequence and indicate that it should be mirrored for looping usage. The exact output representation might vary, but conceptually the ping-pong path is not a loop in one direction but rather a path that retraces itself. Therefore, no new colors are generated in the backward pass; it’s the same path. The engine ensures the forward and backward are exact inverses so the only “pause” is at the extreme anchors if one chooses to treat them as points of reflection (some implementations repeat the end anchor, others don’t, to create a continuous oscillation without holding on the ends). In any case, ping-pong leverages the same color computations as the forward path, just in reverse.
The Möbius loop strategy is more intricate. In a Möbius loop, the journey is conceptually closed but with a half-twist – much like how a Möbius strip joins its ends with a 180° twist. Translated to color, this means that after one traversal of the sequence, you do return to a color that looks like the starting color, but somehow “inverted”. A practical interpretation is: after one pass, you land on the starting color’s complementary or a variant that is diametrically opposite in some attribute, and only after a second pass do you return to the true start. For example, imagine a journey that starts at a given red. A Möbius approach might cause the sequence to end at a color that is also red in appearance – but perhaps with hue rotated 360° (which is actually the same red again) but with a property inverted (maybe the path carried an implicit phase such that you consider it flipped). In more concrete terms, one way to implement a Möbius loop is: double the period (t goes from 0 to 2 for a full cycle), and impose a rule that at t=1 (halfway) we have the same hue as the start but 180° rotated in hue-space or inverted in lightness. For instance, it could cycle hue twice as fast such that in one run it covers two cycles of hue, causing a half-winding offset. Another approach: treat one of the Lab axes as flipping sign each loop. A simple idea: after one loop, you return to (L, a, b) = (L, –a, –b) which is the exact opposite chroma direction (this would be the complementary color of the start if L was the same). Then after the second loop, you’re back to (L, a, b). This indeed mimics a Möbius: you need two traversals to return to original orientation. The engine can create this effect by constructing the journey for 0 ≤ t ≤ 1 from A_1 to some “inverted A1” (call it A_1'), which might just be A_1 mirrored through neutral (like same L, but hue rotated 180°, effectively complementary color). Then for 1 ≤ t ≤ 2, it goes from A_1' back to A_1. The resulting full cycle (0 to 2) returns to start, but the halfway point is an alternate form of the start. To the viewer, if the sequence is shown continuously, it will look like a continuous loop that takes two iterations to truly repeat. The benefit of this is creating a sense of continuous change without a obvious loop point, since after one iteration you’re not exactly at the initial color but something very close (maybe the complementary). This strategy is more niche and conceptually complex, but the engine’s design allows for it by effectively doubling the path and inserting a twist. In output terms, a Möbius sequence might be output as a list of colors from t=0 to t=1 (which ends on the complement of the start), with the understanding that repeating that list twice completes the cycle back to the original color. Alternatively, it might output the full two-length sequence explicitly.
In summary, the engine modifies the journey for closed, ping-pong, or Möbius as needed, by either adding connecting segments or by structuring the parametric path appropriately. After this step, we have a final continuous description of J(t) for the full journey including any looping considerations. At this stage, J(t) is fully defined for t ∈ [0,1] (for open), [0,1] cyclic (for closed), [0,2] periodic (for Möbius double-length or ping-pong double pass). The description is still mathematical – e.g. we might have piecewise functions for L(t), a(t), b(t) or an algorithm to compute a color at any parameter t.
	6.	Sampling the Journey into Swatches: Because the output needs to be a discrete list of color values (a swatch array), the engine samples points along J(t) to produce a finite sequence. If the user requested a specific number of colors N (common when generating a palette of N swatches), the engine will take N evenly spaced parameter values along t from 0 to 1 (or 0 to the end of cycle if needed) and compute J(t) at those. For example, for an open journey from t=0 to t=1 with N swatches, it would sample at t_k = \frac{k}{N-1} for k = 0…N-1 (so that t_0 = 0 gives A_1 and t_{N-1} = 1 gives A_m, including all anchors if N is sufficiently large or exactly equal to m). If no number is specified, the engine might default to a certain resolution or decide based on anchor count (e.g., output a swatch at every anchor and maybe some between if needed). For continuous uses (like if the colors will be used in a gradient where interpolation is anyway done by CSS or code), the engine could output just the anchors or a minimal set, but typically for a smooth palette, a moderate number like 5–10 swatches are output or whatever the user requests.
If ping-pong or Möbius, the sampling covers the extended range accordingly (for ping-pong, forward and backward; for Möbius, possibly 0 to 2). The user might also specifically ask for a cyclic palette with a certain number of colors; for a closed loop, the engine might then space N points around the loop evenly.
During sampling, if variation is enabled, the engine will also introduce the pseudo-random perturbations. These perturbations are not large enough to derail the journey, but they add subtle variety. For instance, the engine might slightly jitter the position of some sample points or jitter the color values themselves by a small delta in Lab space. Because we want to keep anchors fixed, the perturbation could be zero at anchor positions and maximum mid-segment. A typical approach: for each sample at parameter t_k that lies between anchors, add a small offset \delta L, \delta a, \delta b drawn from a pseudo-random sequence (e.g. seeded noise function or a fixed sequence like Perlin noise evaluated at t) scaled by some “variation strength” parameter. The random seed ensures the noise pattern is the same each time for given seed. The variations might make the path slightly wavy in color space rather than perfectly smooth. Importantly, these variations should still respect constraints: for example, we wouldn’t allow a random bump to push a color out of gamut or overshoot an anchor’s value. So the engine might clamp or reduce variation as an anchor is approached (s.t. anchor colors remain exact) and also check any post-perturbation color against the gamut and contrast rules. The variation can also be applied at the path definition stage instead (for example, by randomly offsetting the control points of a spline), which would then inherently affect all samples. Either way, by the time we sample final swatches, the pseudo-random offsets are included in the color values.
	7.	Gamut Mapping and Constraint Enforcement: After obtaining the list of sampled colors in OKLab (or a similar space), the engine validates that they all meet the required constraints. The most critical is gamut: any color that lies outside the target gamut (e.g., has any sRGB channel < 0 or > 1 when converted) is adjusted. Gamut mapping can be as simple as clipping (capping values to [0,1]), though a perceptually better approach is chroma reduction – if a color is out of gamut, it’s usually because it’s too saturated or too bright for the sRGB range, so one can reduce its chroma C until it falls inside the sRGB solid while keeping the same hue and perhaps adjusting lightness minimally ￼. The engine likely employs a strategy like: convert the Lab color to sRGB; if any channel is out of [0,1], do a binary search scaling of the color’s distance from neutral gray (mix it with gray or reduce saturation) until it fits. Because OKLab itself has no inherent bounds ￼, such mapping ensures final values are representable. If any other constraints are set (for example, maybe the user requires a minimum contrast ratio between the darkest and lightest colors for accessibility, or a constraint that lightness must monotonically increase), the engine would check those now and if needed, make minor adjustments. For instance, if the darkest and lightest swatch don’t have enough difference, the engine could darken the darkest and lighten the brightest slightly (unless anchors prevent it) or it could simply warn the user. In general, the engine tries to solve constraint violations by small nudges that don’t violate anchors or overall smoothness: e.g., compressing or expanding the L range, clipping chroma to a max value if too high, etc., all done in Lab space to maintain perceptual consistency.
This enforcement step might iterate: fixing gamut might reduce contrast, so if a contrast constraint exists the engine may then tweak something else. However, because our scope avoids deep implementation, we assume these adjustments are either minimal or the configuration is such that major conflicts don’t occur often.
	8.	Conversion to Output Format: Finally, the list of OKLab colors (now all valid and constrained) is converted to the desired output color representation. Typically this would be sRGB for web use. Each Lab color is converted to XYZ and then to linear sRGB and gamma-encoded to standard sRGB values, then formatted as per request – e.g. hex #RRGGBB strings, or rgb(R,G,B) percentages, etc. The engine ensures the conversion uses the correct color profiles (D65 whitepoint for OKLab vs sRGB alignment) so that colors are accurate. If CSS Level 4 color syntax is acceptable, the engine could also output lab(L% a b) or oklab(L a b) strings directly ￼ ￼, but since broad compatibility is a concern, default might be hex or rgb(). The output is then an array of swatches, where each swatch is a color value in a standard format.

The result of this algorithm is a sequence of colors ready for use. For example, consider anchors A_1 = \text{#0020FF} (a deep blue) and A_2 = \text{#FFD020} (a golden yellow), and suppose the user chooses an open journey with a slight warmth bias (to avoid dull intermediate), moderate vibrancy, and 5 output swatches. The engine would compute something like: Starting at #0020FF, in Lab it’s (L≈30, a≈40, b≈-100); ending at #FFD020, Lab (L≈90, a≈-5, b≈80). A straight line interpolation might pass through neutral gray around L≈60. But with warmth bias, it might route through purple (increasing a to positive before dropping it) so the mid color isn’t gray but a desaturated magenta or brown. With vibrancy, it might keep the saturation a bit higher. The final output could be an array like:
	•	#0020FF (the blue anchor),
	•	#5A23CC (a blue-violet),
	•	#9450A0 (a muted magenta/gray),
	•	#D28950 (a warm brownish),
	•	#FFD020 (the yellow anchor).

This is just a conceptual example, but it illustrates that the colors smoothly morph from blue to yellow, and the middle is not a flat gray but a more colorful blend due to the biases. All output are in gamut (being valid hex codes) and ready to be used in CSS, for example as a gradient: background: linear-gradient(to right, #0020FF, #5A23CC, #9450A0, #D28950, #FFD020);. A developer can use these directly for UI theming, visualization, or any purpose.

With the journey construction logic explained, we will delve a bit deeper into specific aspects: how exactly the dynamic parameters influence perceptual properties, how looping modes are conceptually handled, how variation works in a deterministic way, and then finalize with output structure and usage considerations.

Dynamics and Perceptual Biases

Dynamics refers to the configurable variations in how color attributes change along the journey. The engine’s dynamic control parameters allow the developer to introduce perceptual biases deliberately – essentially shaping the geometry of the color path beyond the straight-line interpolation. We have touched on these in the algorithm description; here we provide a more formal and separate discussion of each major dynamic parameter and its effect:
	•	Lightness Dynamics: This parameter controls the progression of the lightness (L) component along the journey. Without bias, L would interpolate linearly between anchor L values. By adjusting lightness dynamics, the user can make the gradient appear “lighter in the middle” or “darker in the middle”, or have an ease-in/ease-out behavior in brightness. Formally, if anchor A_i has lightness L_i and A_{i+1} has L_{i+1}, the unbiased interpolation would give L(\alpha) = L_i + \alpha (L_{i+1} - L_i) for \alpha \in [0,1]. With a lightness bias function f_L(\alpha), we redefine L(\alpha) = L_i + f_L(\alpha)\,(L_{i+1}-L_i). The function f_L(\alpha) is chosen such that f_L(0)=0 and f_L(1)=1 (so endpoints remain anchored), but in-between it might be higher or lower than the straight line \,f_L(\alpha)=\alpha\,. For example:
	•	If the user selects “ease-in-out” for lightness, the engine might use f_L(\alpha) = \alpha^2 (3 - 2\alpha) (a smoothstep function). This starts L changing slowly (staying near L_i longer), then speeds up, then slows as it approaches L_{i+1}. Visually, that produces a gentle transition that lingers on the starting brightness and carefully eases into the final brightness – useful if you want to avoid abrupt brightness changes at endpoints.
	•	If the user wants a dramatic contrast (emphasized ends), the engine might use an S-curve as described earlier, for instance f_L(\alpha) = \frac{\alpha^p}{\alpha^p + (1-\alpha)^p} with p > 1. This keeps mid-range values nearer 0.5 in \alpha to actually be lower in f_L, meaning the middle of the segment appears darker relative to a linear path (if L_{i+1} > L_i) or lighter (if the segment is descending). Essentially it boosts the difference by pushing more change to the middle of the segment.
	•	A “dome” or “dip” in lightness can also be achieved: If the user specifically wants the journey to go lighter than both anchors in the middle (a hump), this requires anchors not at extremes or the ability to overshoot. The engine typically would not overshoot anchor L’s by default (to preserve anchors), so an anchor at the highest brightness would limit that. But if anchors allow, the engine could implement a hump by e.g. raising L slightly above a linear line at midpoint. This could be done by a function like f_L(\alpha) = \alpha + k \sin(\pi \alpha) with a small amplitude k, which has a bump at α=0.5. However, such overshooting must be constrained so that if anchor lightness are at 0 and 1 (extremes), we don’t exceed [0,1]. Typically, dynamic controls would avoid overshooting anchors for simplicity. So it’s safer to imagine lightness dynamics as controlling easing shapes rather than actual overshoot.
The effect of lightness dynamics is often to adjust the perceived contrast and brightness distribution of the palette. If done well, one can ensure the palette doesn’t have unintended dim spots or overly bright flashes. It also interacts with human perceptual bias: humans are very sensitive to lightness differences, so fine-tuning L can dramatically change the character of the color sequence (e.g., a monotonic increase in L can make a gradient look like it’s steadily “revealing light”, whereas a dip in L halfway can create a moment of shadow or depth).
	•	Chroma Dynamics: This governs how saturated or colorful the intermediate colors are relative to the anchors. A straight interpolation in Lab usually results in chroma not dropping below the linear mix, but sometimes it can if anchors are complementary. Chroma dynamics allow the user to avoid “washing out” or conversely to deliberately mute the transition. Formally, if C_i = \sqrt{a_i^2+b_i^2} and C_{i+1} are the chromas of anchors, linear path in Lab might result in a chroma that is also linear or even curved implicitly by hue. We introduce f_C(\alpha) such that desired chroma C(\alpha) = (1-\alpha) C_i + \alpha C_{i+1} (linear base) times f_C(\alpha). If the user sets a high vibrancy starting mid-segment, f_C(\alpha) could be >1 around α=0.5. For example:
	•	A vibrant boost profile: f_C(\alpha) = 1 + u \sin(\pi \alpha), where u is some factor (u=0 means no change; u=0.3 might give +30% chroma at midpoint). This would make colors in the middle of the segment more colorful than the linear path would produce. If the linear path was going through a gray zone, this effectively avoids the gray and yields a richer hue.
	•	A desaturated middle profile: f_C(\alpha) = 1 - d \sin(\pi \alpha) with d > 0, doing the opposite – maybe you want the palette to temporarily become nearly monochromatic in between (for a stylistic fade to gray then back to color).
	•	A monotonic adjustment: If user just has an overall vibrancy slider, the engine might uniformly raise or lower chroma: e.g., if vibrancy=110%, simply multiply all computed chroma by 1.1 (and clamp to gamut). That’s a simpler global approach. But often vibrancy is intended to especially affect colors that would otherwise be dull – akin to the concept of vibrance in photo editing which leaves already vibrant colors alone but boosts muted ones ￼. The engine could mimic that by saying: for any color where C is below some fraction of max(C_i, C_{i+1}), boost it. Implementation might be nonlinear, but qualitatively, low chroma segments get amplified more than high chroma ones. This ensures no color in the journey looks too washed-out unless both anchors were themselves gray.
The effect of chroma dynamics is to control how vivid the palette is throughout. Without control, some transitions might look dull especially when going between complementary or distant colors (since the path may pass near the center of Lab space = gray). By increasing chroma in the middle, the engine can produce a more striking, colorful gradient. Conversely, by decreasing it, the engine can create a more toned-down, pastel or grayscale transition if desired. This is a creative choice for the palette’s emotional tone (vibrant vs subdued).
	•	Warmth (Hue Bias): Warmth dynamics deal with the hue angles. The user can influence whether the color path leans towards warm hues (reds, oranges, yellows) or cool hues (greens, blues, purples) as it transitions. Since hue is a circular parameter, the main choice is which direction around the circle to interpolate, as described. Let’s define \Delta h = \text{mod}_{360}(h_{i+1} - h_i) in the principal range (–180°, 180°]. The engine by default picks the smaller absolute Δh to minimize hue travel. Now define a bias parameter w \in [-1, 1] representing full cool (–1), neutral (0), full warm (+1). A simple approach: if w > 0, rotate the hue difference in the positive (increasing) direction even if that’s longer; if w < 0, rotate negative direction; if w = 0, do the shortest path. A smoother approach: one could interpolate between the short path and long path based on w. For example, the actual chosen Δh might be: \Delta h_{\text{chosen}} = (1 - |w|) \Delta h_{\text{short}} + |w| \Delta h_{\text{long in preferred direction}}, where “long in preferred direction” means if w is positive, the Δh that goes the warm way (which might be Δh + 360° if short was negative, or just the same if short was already positive but anyway we ensure passing through warm quadrant), if w is negative, similarly the other way. This way, w can gradually influence how much of the journey goes via the warmer side.
Regardless of formula, the result is a different path in the a–b plane. Instead of a straight line between (a_i,b_i) and (a_{i+1},b_{i+1}), it will bow out in one direction. One might also incorporate the idea that certain hues are inherently warm: e.g., maybe any path will slightly gravitate towards 60° (yellow) if warmth bias is high, even if not necessary. However, it’s safer to do it relative as above.
If m>2, and multiple segments, warmth bias can apply segment-wise or globally. Possibly a global warmth setting biases every segment’s hue interpolation to the warm side. This could lead the whole palette to favor reds/yellows. If one segment is between two cool colors (blue to green), warm bias might then choose the longer path passing through red, which is a big detour (possibly unexpected if anchors are close). The engine or user might decide to only apply bias when there’s an ambiguity or up to a certain limit. But that’s implementation detail.
The perceptual effect of warmth bias is straightforward: it can produce two very different gradients between the same anchors. For instance, between purple and green, a cool-biased journey would go through blue (cool colors) whereas a warm-biased one goes through magenta and orange. Both end at green but the intermediate colors differ drastically in mood. Warm-biased palettes tend to evoke sunsets, autumn, or warm light feelings; cool-biased evoke oceanic, icy, or technological feels.
	•	Vibrancy: We touched on vibrancy as global chroma boost, but some systems treat vibrancy as slightly different from saturation. In many design contexts, vibrancy could mean ensuring the colors are lively but not oversaturated in an unpleasant way. The engine could interpret vibrancy as an intelligent saturation control that increases chroma especially for mid-saturation colors and protects skin-tones or such (though here no concept of skin-tone). In our context, vibrancy may overlap with chroma dynamic or be a combination of chroma and lightness adjustments (since very high saturation might require adjusting lightness to maintain visual balance). For example, making a color more vibrant often involves not just saturating it but sometimes also making it a bit lighter if it was a dark color, so it “pops” more. The engine could incorporate a vibrancy parameter that globally scales chroma and slightly adjusts lightness upward for dark colors or downward for very light colors to avoid light washout. This is an advanced nuance; at high level, one can say vibrancy controls the overall intensity of color. A vibrancy of 0 might yield a grayscale version of the journey (all chroma reduced to 0, only lightness changing), whereas vibrancy of 1 (100%) yields the default, and vibrancy >1 might yield extra vivid colors (until limited by gamut).
In the engine’s formal approach, vibrancy might multiply all computed chroma by a constant factor v (with some cap so that if any color hits the gamut boundary, further increase yields diminishing returns). Or it might be implemented as part of the chroma dynamics function as described. It’s conceptually separated here as “global saturation level”.
	•	Contrast Dynamics: This parameter can be interpreted in two ways, both of which the engine can implement:
	1.	Global Contrast (Lightness Range): A contrast setting can stretch or compress the overall lightness span of the palette. The engine can compute the lightness of all output colors and find L_min and L_max. If contrast needs to be higher, it can try to reduce L_min (darker) and increase L_max (lighter) by a certain percentage towards 0 and 100 respectively. However, if anchors define those extremes, it can’t go beyond them unless allowed. If anchors are not at the extremes, it has room. For example, if anchor1 L=30 and anchorN L=80, a high contrast request might shift them to maybe 20 and 90 (assuming slight anchor adjustment is allowed or one of them is not fixed – typically anchors are fixed though, so this is tricky). More likely, if anchors can’t move, the engine can still adjust intermediate lights: e.g. to emphasize contrast, it can cluster mid values away from middle. That’s essentially what we did with lightness S-curve. So global contrast could just map to using a stronger S-curve on L distribution across the entire journey. So it overlaps with lightness dynamic indeed. The difference is global contrast might consider the entire set of output, not segment by segment, to ensure the first and last outputs are at certain relative difference.
	2.	Local Contrast (Adjacency): Another facet is ensuring each color is sufficiently distinct from the next. If a user cranks up contrast, they likely want fewer, bigger jumps between colors rather than a subtle gradient. The engine could respond by reducing the number of output steps or by nonlinearly picking sample points such that each step has a larger ΔE. For instance, normally if we output 5 steps from dark to light, they might be 20, 35, 50, 65, 80 in L. High local contrast might result in say 20, 40, 60, 80, 100 – bigger jumps (and likely fewer steps would be needed because going all the way to 100). However, the number of output swatches might be fixed by the user; if not, the engine might choose fewer steps for high contrast. But typically, number is given, so we then just space them nonlinearly (which we anyway do via dynamic curves). So again, it circles back to an S-curve or other shaping that ensures differences are accentuated.
The engine can quantify contrast in terms of ΔE between darkest and lightest, or average ΔE between neighbors. It could attempt to meet a target (like ensure min ΔE between any adjacent ≥ X for readability reasons, if that was a constraint).
In summary, the contrast parameter is primarily about the lightness dimension extremes, since perceived contrast is heavily tied to luminance difference (especially for accessibility: WCAG contrast is purely a luminance ratio metric). So a high contrast palette will likely have one or more colors that are much darker and one that is much lighter, increasing visual range. A low contrast palette will be more uniform in lightness, perhaps all pastel mid-tones.
It should be noted the user’s notion of contrast might also include color contrast (like complementary hues). However, usually that’s not what “contrast” slider means; complementary hues could be achieved by anchors themselves (like if you choose anchors far apart on color wheel, you get more contrast in hue). The engine doesn’t explicitly have a “hue contrast” slider beyond the anchors and warmth. So we assume “contrast” is focusing on light/dark difference and maybe saturation difference.

To implement these biases carefully, the engine ensures that anchor values themselves are not changed (except possibly global vibrancy/contrast might tweak them if allowed or if they are not absolute – usually anchors are absolute though). Thus f_L(0)=0, f_L(1)=1 etc guarantee anchor consistency at segment boundaries. The biases mostly influence the interior of segments.

One must also consider interplay: If the user sets multiple biases at once, the engine combines them. Often the influences are somewhat separable: one can compute baseline path, apply L bias to L coordinate, apply hue bias to path direction, apply C bias to a,b magnitude. However, there are interactions (e.g., boosting chroma might push a color out of gamut if simultaneously the hue path goes through a saturated region at high L; or a strong lightness S-curve plus a strong chroma boost might make the mid color extremely saturated and dark, maybe problematic). The engine likely has some internal logic to moderate extremes when multiple biases combine – but in conceptual terms, it applies all as instructed and then relies on the constraint enforcement later to fix issues like gamut.

Overall, dynamic parameters give the developer a high-level, intuitive handle to tweak the character of the color journey:
	•	“Make it brighter at the end” -> increase contrast or adjust anchor lightness.
	•	“Make the middle pop with color” -> increase vibrancy.
	•	“Avoid going through green, it should stay warm” -> set warmth bias to warm.
	•	“Keep colors kind of similar, not too much difference” -> lower contrast, maybe lower vibrancy.

These changes are done without the developer needing to pick specific intermediate colors; the engine does it mathematically. This significantly speeds up palette experimentation, as one can see the effect of these parameter changes immediately on the palette output.

Looping and Path Closure Logic

Color journeys can be used in contexts where the sequence is meant to repeat or cycle, such as rotating LED lights, looping animations, or continuous UI themes that transition through colors. The engine’s loop strategies determine how the end of the color list relates to the beginning. We have introduced the four modes – open, closed, ping-pong, and Möbius – conceptually; here we clarify their differences and how the engine achieves each.
	•	Open Path: This is the default interpretation for a journey that is not explicitly closed. The sequence of colors goes from the first anchor to the last anchor and then stops. There is no attempt to connect the last color back to the first. The output is effectively a finite gradient or palette. Open mode is appropriate for use cases like a one-time transition (e.g. a fade from one color to another) or a categorical palette that doesn’t need wrapping. In open mode, the engine’s only task is to generate the colors between anchors in order; no special treatment is needed at the boundaries beyond hitting the anchors. If you were to loop an open sequence in a display, you would likely see a jump at the loop point (from last color back to first), because no continuity is enforced there. The engine doesn’t consider that a problem in open mode – it simply assumes no looping or that the user will handle any wrap-around if it’s desired (perhaps by requesting a closed journey instead).
	•	Closed Loop: In closed mode, the engine treats the journey as cyclical: after the last anchor, it should seamlessly transition back to the first anchor. This effectively means A_1 and A_m should be adjacent in the color path. If the user actually provided A_1 and A_m as the same color, then the situation is trivial: the anchors already close the loop. But typically anchors will be different and we want to loop them. The engine will add a segment from A_m back to A_1 (unless perhaps the user explicitly included A_1 again as A_{m+1}, but normally one wouldn’t list duplicates).
The challenge with closed loops is ensuring smoothness at the join. The engine uses the same interpolation logic for the last segment A_m \to A_1 as for any other segment, subject to biases. But one must consider that at A_1 (which appears at both t=0 and t=1 of the closed path) the incoming and outgoing paths should line up. If a smoothing spline is used through anchors, and we treat A_1 and A_{m+1}(=A_1) as the same point, a closed spline can be generated by solving it in a periodic manner (ensuring the derivative at A_1 from segment 1 equals the derivative at A_m \to A_1. This can be done by a slight adjustment to how control points are computed, effectively linking the first and last). If a linear or simple bias path is used, then a linear closing might yield a corner at A_1 unless by coincidence the slope matches. To avoid a noticeable corner, the engine might by default apply an extra smoothing just at that join for closed loops. Another technique is blending the end of the last segment and start of first segment a bit – since both meet at A_1, one could ensure their incoming/outgoing directions average out. But these details aside, the output will ensure that the last few colors approach A_1 gently from A_m. The final output array for a closed loop might actually exclude the repeated end color because the first color in the list already provides it. For example, if anchors are A, B, C and closed loop, the path goes A→B, B→C, C→A. The engine might output [A, …, B, …, C] and not repeat A at the end, but the understanding is that if used cyclically, after C comes A again seamlessly. If the user explicitly wants the cycle represented twice or continuously, they can always loop the array.
A closed journey is useful for e.g. color pickers that allow a cyclic hue ring or dynamic lights that continuously cycle without abrupt resets. It’s essentially a loop around some path in color space – not necessarily around a pure hue circle (because anchors could cause it to meander), but ultimately returning to start.
	•	Ping-Pong: Ping-pong is not a closed loop in the sense of ending at the same color with the same orientation; instead, it’s a strategy to allow back-and-forth oscillation. The sequence goes to the last anchor then reverses exactly. If you arrange the colors in order and then back, it becomes a loop of period 2*(N-1) in terms of steps (if N is number of unique colors in one direction). The reason to use ping-pong mode is often for animations where you want to avoid a sudden jump when looping, but you prefer the path of colors to retrace rather than to form a new connecting link. Ping-pong is symmetrical: the forward and backward path are the mirror image in color space.
The engine constructs ping-pong by first generating the open journey A1…Am (with any biases as specified). Then it creates the reverse of the interior: Am-1…A2 back down to A1. Note that the anchors in the middle (A2 through A_{m-1}) will appear twice in the full cycle, once on the way up, once on the way down. Usually the extreme anchors A1 and Am serve as the turning points and appear once each if you conceptually loop (because you go A1→…→Am, then Am→…→A1, and if repeating, you’d go back to Am etc, so A1 and Am would repeat at loop boundaries). If one strictly outputs a single cycle, they might list A1..Am..A2 then back to A1. It’s up to implementation whether to duplicate A1 at end or not (similar to closed loop case).
The important aspect is continuity: at the turning anchor (like Am), the forward sequence naturally goes into that anchor and then the backward sequence leaves from it immediately with the same slope but reversed direction, which actually results in a continuous first derivative if the path was linear and we just reverse it. Essentially, going forward and then backward along the same path yields no sharp corners at the turnaround if time is continuous. However, if you treat it as an instantaneous reverse, one might argue at the exact moment of turning, the velocity vector in color space goes through zero and reverses – but visually if you’re just cycling colors, it doesn’t matter because staying at Am to then go back through the same hues is fine (the color stops changing direction because it stops and goes back). There is no new color introduced; it’s a smooth reversal. In practice, ping-pong ensures that if you animate forward then backward, you will see a smooth back-and-forth with no jumps, as long as you do not skip the anchor.
The output for ping-pong can be thought of as doubling the list minus one at the end. For example, if an open journey (non-pingpong) gave [A, X, Y, Z, B] from A to B, then ping-pong output would be [A, X, Y, Z, B, Z, Y, X, A]. Typically B and A at the ends might be repeated or not depending on loop. The engine likely outputs the full back-and-forth explicitly if asked for ping-pong mode, or provides a function to get color at a param that oscillates (which is akin to J_{ping}(u) = J(|1 - \text{mod}(u,2)|) effectively reflecting the parameter in [0,1]).
Ping-pong mode is especially useful in scenarios like “animate the background color to transition from blue to green and back to blue continuously”. The engine would give a palette that goes blue→…→green→…→blue with no break.
	•	Möbius Loop: A Möbius loop is the most complex mode. It creates a continuous cycle that returns to the start color only after two iterations, introducing a kind of alternating sequence. Practically speaking, a Möbius loop mode is useful if you want an animation or cyclic palette that does cycle but you don’t want it to simply repeat the same sequence every loop; instead, you want an alternation between two sequences. For instance, the user might perceive that after one loop, the colors are similar but not identical to the starting arrangement (maybe some are swapped or complementary), and only after two loops do things align perfectly. This introduces a subtle variety in each cycle of a repeating pattern.
The engine implements Möbius by introducing a half-twist in color space. One interpretation, as mentioned, is to connect last anchor to something like the “inverse” of the first anchor. How to define inverse? Possibly the opposite hue (rotate 180°) and maybe keep lightness same. For example, if start anchor A1 is red, after one pass through all anchors, the color that corresponds to “back at A1 position” would actually be a cyan (complement of red) if we did a pure 180 hue twist. But we label that cyan as if it’s the same anchor position. Then continuing the journey one more time brings it back to actual red. This yields a two-pass cycle. Another approach is to phase-shift all hues by 180° on each cycle. That’s effectively the same idea: in the first iteration, everything’s hue is offset by 0°, in the second iteration by 180°, then back.
The formal way: if J_{\text{closed}}(t) is a normal closed loop param 0→1 from A1 to A1, then for Möbius we define J_{\text{mobius}}(t) for t from 0 to 2 such that:
	•	J_{\text{mobius}}(t) for t∈[0,1] goes from A1 to A1’, where A1’ is A1’s twisted counterpart.
	•	J_{\text{mobius}}(t) for t∈[1,2] goes from A1’ back to A1 (at t=2).
	•	J_{\text{mobius}}(0) = A1 and J_{\text{mobius}}(2) = A1 so overall after t=2 you loop.
	•	But J_{\text{mobius}}(1) = A1' which is not A1 but some transformed version (like complementary color or something).
If we think in Lab, one simple twist is: take the a and b components and flip their sign at the halfway. That indeed makes a complement (if a,b turned to -a,-b gives opposite hue). However, if A1 was gray (a=b=0) flipping does nothing, but that’s fine. So one path to do this: Let’s assume for anchors we can define their complements as well. Actually, do we need to consider intermediate anchors? The twist likely applies to the whole sequence as one object. Perhaps easiest: The engine computes a closed loop normally through anchors but with an additional condition that half-way it hits each anchor’s complement simultaneously (which would be weird unless m=1 maybe). Actually, maybe an easier concept: restrict to one anchor (the Möbius concept is easiest to illustrate with one anchor or a symmetric set). If one anchor, we already said the path could go out and come to complement at half and back to original. If more anchors, maybe the idea is that after one loop, each anchor’s position in sequence is taken by a color related to the original anchor but twisted. For instance, if anchors were A, B, C, then one loop might go A→B→C→something (maybe near A but not A, like A’s complement). Then the next loop goes that complement of A → complement of B → complement of C → back to original A. This is complex to implement generally unless maybe the anchors themselves come in complementary pairs or something.
Given complexity, the engine might restrict Möbius mode to cases with symmetrical anchor configurations, or it might simply define it for one anchor scenario as originally intended. However, since the problem statement listed Möbius among strategies, presumably it’s implemented generally. Possibly they define the color journey in such a way (maybe working in a double-length param space and applying a continuous twist rotation in hue or in Lab a,b plane) that after one param run, you are at rotated coordinates. A mathematical representation:
	•	Represent the journey as J(t) = (L(t), a(t), b(t)) for t in [0,2] with periodic boundary 2→0.
	•	Impose that J(2) = J(0) (closed) but J(1) = (L(0), -a(0), -b(0)). Also ensure similarly for intermediate anchors if any (which is tricky, perhaps intermediate anchors must also map to some twisted counterpart at half cycle – likely meaning anchor count might need to be even or something).
Without diving too far, the effect is that the sequence of colors for 0≤t<1 looks like a certain transition, and for 1≤t<2 it looks like the “negative” of that transition. If you only look at color appearances, if the twist is exactly 180° hue rotation, the set of colors from t in [1,2] is actually the complementary palette of the [0,1] range. If displayed one after the other, the palette goes through a set of colors, then an alternate set that are complements, then repeats. This can be visually interesting – e.g., a design that flashes complementary colors on alternate cycles while still being continuous.
For user perspective: Möbius mode would be selected if they specifically want that alternating complementary behavior. Otherwise it’s not common. The engine provides it as a creative option.
Implementation wise, perhaps easiest: treat the journey’s hue as ramping twice as fast so that by t=1 the hue has shifted 180°, and treat lightness and chroma normally but allow a and b sign flip at t=1. That naturally happens if hue goes 180 difference anyway in Lab. Actually, yes: if we continuously rotate hue beyond the 360 needed to loop, by 720° total in two loops, that implies at half the loop we are 360° off in hue relative to start, which is the same hue again, so that wouldn’t invert. Instead, we need a 180° offset after one iteration. That means if overall after 2 cycles hue rotates 360°, after 1 cycle it rotated 180°. So we could say define hue path such that from t=0 to t=2, hue rotates by some total. If anchors define relative changes, it’s complicated unless anchors themselves symmetrical. Possibly, the engine might apply Möbius only to an anchor-less (or rather single anchor) scenario, or treat all anchors similarly with a global twist.

In summary, the loop strategies alter how the final output is structured, but the underlying approach remains using the same interpolation methods with either an added segment (closed), reflection (ping-pong), or extended periodic conditions (Möbius).

To solidify understanding, consider a concrete example:
	•	Anchors: A_1 = pure red (#FF0000), A_2 = pure green (#00FF00).
	•	Open journey: would yield a straight gradient from red to green (passing through some yellow/brown depending on color model). The last color is green, first is red, no continuity if repeated.
	•	Closed loop: will add a path from green back to red. Likely that path might go through blues or magenta (because going from green to red around the other side of the color wheel maybe). So the full loop might be: red → yellow → green → cyan → blue → red. That covers a loop around the hue circle. The output excluding duplicate red might be: [red, yellow, green, cyan, blue] and if you go from blue back to red it’s smooth (blue to red are neighbor on this path).
	•	Ping-pong: would go red → … → green, then green back to … → red. So it might output [red, yellow, green, (and then backward) yellow, red]. So it basically oscillates between red and green through yellow.
	•	Möbius: might produce something weird like: red → yellow → green on first half, then (complement of red is cyan) presumably at t=1 we should be at cyan, then continue cyan → maybe bluish? → back to red at t=2. So the first cycle gave red→green, second gave cyan→red. If you animate, you’d see red shifting to green, then turning blueish then to red. At the exact half-cycle, instead of going back to red, you found yourself at cyan (which is not in original anchors but it’s the red twisted). So yes, it alternated the target essentially. This might not be intuitive in this simple two anchor example but that’s the gist.

The engine ensures in all cases that the transitions themselves remain smooth; the differences are mainly how the end connects to the start.

Variation and Pseudo-Random Determinism

While the deterministic interpolation of colors yields perfectly smooth and often predictable results, sometimes a designer might want to inject an element of randomness or natural variety into the palette. The Color Journey Engine accommodates this via a variation feature that adds pseudo-random perturbations to the journey, in a way that remains deterministic given a fixed seed.

Pseudo-Random Variation: The idea is to introduce controlled randomness – “controlled” in that:
	•	The general character and constraints of the journey are still preserved (anchors, overall biases, gamut limits, etc., are still respected).
	•	The variation is bounded so that the output doesn’t deviate wildly from the base path – it might add a bit of texture or unpredictability, but not so much that one anchor color might be replaced by something completely off-theme.
	•	The randomness is repeatable: by seeding a random number generator (RNG) with a user-provided seed, the sequence of random choices becomes fixed, ensuring that the same seed always produces the exact same color journey, and different seeds produce alternate versions.

This approach is often called pseudo-random determinism: the engine’s output is random-looking but not truly random each run; it’s locked by the seed. This is crucial for developers who need consistency (e.g., you generate a palette for a procedurally generated artwork – using the same seed later should reproduce the same palette, allowing consistency across sessions or easier debugging).

How variation is applied: The engine can add variation at various points in the pipeline:
	•	It might perturb the path geometry itself. For instance, if using a spline through anchors, the engine could randomly offset the control points of the spline within some limit. This would cause the entire color path to wiggle or wander a bit instead of being a perfect mathematical curve. For example, between two anchors, instead of a perfectly smooth monotonic change in hue, maybe it wiggles to a slightly unexpected hue before coming back. This can make gradients look more “organic” or less computer-perfect, which sometimes is desired in generative art or theming (to avoid a sterile look).
	•	It might directly perturb the colors after initial computation. For each intermediate color, one could add a small ΔL, Δa, Δb drawn from a distribution (e.g., Gaussian noise with mean 0 and a small standard deviation). This is a simpler implementation: after computing the ideal palette, just nudge each color slightly in a random but controlled way. Anchors themselves would typically not be nudged (or only nudged if the user explicitly allowed anchors to shift).
	•	It might randomize the dynamic parameter functions in subtle ways. For example, instead of using the exact same ease function for every segment, maybe pick a slightly different exponent for each segment (with seed controlling it). This would produce small differences in how each segment looks.
	•	Variation can also manifest as random selection among discrete options. For example, if the warmth bias is neutral (0) meaning the engine could equally go warm or cool path between two anchors, maybe the engine uses the seed to randomly pick one path or the other. That means sometimes the journey goes one way around the color wheel, sometimes the other, giving two qualitatively different results. Both results meet the specified “neutral” bias criteria (since both directions are acceptable if neutral), but it adds unpredictability which might be interesting. Such randomness could be extended to other ambiguous choices too (like if multiple equally good ways to avoid out-of-gamut, pick one randomly for some variety).
	•	If a palette is long (many steps), one could add low-frequency noise along the path to create gentle undulations in color. For instance, generate a 1D Perlin noise curve for L, a, b as functions of path length, and add that to the base path. Using Perlin or other coherent noise ensures the variation is smooth over neighboring colors (so you don’t get one swatch oddly out-of-place, but rather a gentle drift).

Regardless of method, the magnitude of variation is controlled by a parameter (the user might specify a “variation strength” or it might be implicitly tied to seed if seed is provided but strength default moderate). Typically, the engine ensures variations do not violate constraints:
	•	If a random perturbation made a color go out of gamut, the engine either rejects that perturbation or scales it down.
	•	If a variation would shift an anchor, the engine likely zeroes it out at anchor boundaries (like applying a tapering window so that noise amplitude goes to zero at anchors). This ensures anchors remain fixed points.
	•	If there’s a constraint like monotonic lightness desired and a variation would break it (like one color slightly lighter than the next when it should be monotonic), the engine might either not allow variation in that scenario or apply a correction after (maybe by sorting the colors by L again or something – but that could break the journey structure, so more likely they disallow that combination).

The pseudorandom sequence generation itself is straightforward for a developer: one could use a fixed PRNG (e.g., XorShift, Mersenne Twister, etc.) seeded with the given integer/number seed. Then each needed random value is drawn from it. The engine might use one random stream for all aspects or separate streams for each attribute if wanting more complex variation control. But since we don’t discuss implementation details, we just assume the effect.

An example to illustrate variation: Suppose the engine without variation outputs a smooth blue-to-green gradient of 5 swatches: [blue, teal, aquamarine, sea-green, green]. With a bit of variation, it might output: [blue, slightly purplish teal, slightly desaturated aqua, slightly yellowish sea-green, green]. The differences are small – each intermediate color is a bit off the perfectly straight line, maybe one went a bit toward purple, another a bit toward gray or yellow. The palette still clearly goes from blue to green, but it has a more “handpicked” feel as if each color has some character. Importantly, using the same seed, you’d get that same particular pattern of shifts every time (e.g., second color always slightly purplish, third always a bit gray, etc.). If you change the seed, you get a different pattern: maybe second becomes more vibrant, third more bluish, etc., but always subtle if variation strength is low.

Another scenario is if the user wants a series of palettes that are all “the same” in the big picture (same anchors, parameters) but each with a unique twist. They could iterate seeds 1,2,3,… and get a family of palettes that differ in the minor details. This can be great for generative art where you don’t want identical repetition.

The determinism guarantee means that if one collaborator uses seed 42 and sees a palette, they can send just “seed 42” to another collaborator who can reproduce it, rather than having to send all color values. It’s like a random recipe that’s re-playable.

We emphasize that the engine does not use any random variation unless specifically asked (seed provided and variation turned on). By default, it’s fully deterministic and repeatable with no randomness (aside from trivial floating-point rounding which is not part of conceptual design). Only when variation is desired do we introduce these pseudo-random elements.

Output Structure and Representation

The final output of the Color Journey Engine is typically an ordered list of color swatches that represent the journey through color space. This section details what this output looks like and how it can be used, especially focusing on compatibility with standard color formats (like those used in CSS for web development).

Swatch Array

The engine outputs a sequence (array or list) of colors: [C_0, C_1, C_2, ..., C_{n-1}]. The order in this array is the path order – C_0 corresponds to the starting anchor (usually A_1), and C_{n-1} corresponds to the ending anchor (A_m for open journeys, or a point close to A_1 again for closed journeys, etc.). Each element C_k in the array is typically a color value in a specified format.

The engine can be configured to output a specific number of swatches n. In many cases, n might be chosen to equal the number of anchors if one only wants the anchors themselves and perhaps one example in between each, but more often n will be larger to get a full gradient. If not explicitly set, the engine might pick a default number of samples (for example, 10 or 16) to give a reasonably smooth palette. The number might also depend on segment count (e.g., maybe 5 per segment times number of segments). In any case, the output array size is finite and usually moderate (since extremely large arrays would be inefficient to manually use; if a user wanted a continuous gradient, they can just use a CSS gradient with color stops from the output or query the engine continuously rather than ask for thousands of discrete swatches).

Color Format

Each swatch in the array is given in a format that is readily usable in the target context (commonly web or design software). The engine supports standard color notations such as:
	•	Hexadecimal (Hex) Strings: e.g., #RRGGBB (with two hex digits per Red, Green, Blue channel). This is a compact and widely recognized format for sRGB colors. The engine ensures to round the internal color values to the nearest 8-bit integers for R, G, B when producing hex. If opacity/alpha is relevant, it could also output 8-digit ARGB hex or separate alpha, but by default we assume fully opaque colors so 6-digit hex.
	•	Functional CSS Color Strings: e.g., rgb(r,g,b) with values 0–255 or percentages, or hsl(h, s%, l%). These are human-readable and can be directly inserted into style sheets or used in code. If the engine works in OKLab but outputs sRGB, it might prefer hex or rgb() because HSL in CSS is not perceptually uniform (though it could convert and output an HSL value that corresponds to the color – but such HSL values wouldn’t reflect the interpolation space).
	•	CSS Color Level 4 formats: new color spaces and functions like lab(L a b) or oklab(L% a b) or lch(L C h) are emerging in modern browsers ￼. The engine could output these, which would be very fitting since it works in OKLab internally. For example, oklab(50.0% 0.2 0.1) would denote a color in OKLab space. However, as of mid-2020s not all browsers fully support these yet (some do under flags), so the engine might not use these by default for compatibility reasons. But it could be an option for advanced users who want to maintain the color in Lab form or to integrate with systems like CSS Houdini color routines.
	•	Object/Array representations: If this engine is used in a programming context (like a design token generator script), it might output each color as a tuple of numeric values, like [R, G, B] in 0–255 or 0–1, or {L, a, b}. But since the prompt says “CSS-compatible forms”, we assume the primary output is something that can directly be placed in CSS or similar. Possibly an array of hex strings is the simplest: e.g., ["#1E90FF", "#4BB4EE", "#78D7DD", "#A4F4CC", "#D1FFC0"] as a JavaScript array literal, representing a path from a blue to a greenish color.

In documentation or a printed paper, one might present the output as a table of swatches with their values. Since this is a conceptual paper, we just describe it textually. For example, if we had a journey output and we want to illustrate, we might say something like:

(Example output): For anchors Red (#FF0000) and Blue (#0000FF) with certain settings, the engine might output an array of 5 swatches: [#FF0000, #BF003F, #800080, #4000BF, #0000FF] – which corresponds to a smooth gradient from red to blue through magenta. Each of these is an sRGB hex color suitable for use on web. The first and last elements match the input anchors (red and blue), and the intermediate values are the generated in-between colors.

The engine does not include any additional metadata by default in the swatch array; it’s simply the color values in order. However, the user can infer or maintain parallel arrays of what those represent (some engines might label anchor points, but here it’s unnecessary since order conveys that implicitly).

Usage of Output
	•	In Code/Stylesheets: A developer can take the swatch array and use it for various purposes. For instance, to create a CSS gradient, one can join the colors: background: linear-gradient(90deg, color1 0%, color2 25%, color3 50%, color4 75%, color5 100%); using the output values as color stops. If an even smoother gradient is needed, one might increase the number of output colors or rely on the browser’s interpolation (but note: the browser’s interpolation by default in CSS gradients is in linear RGB which is now actually perceptual-ish in latest spec, but historically was in sRGB which could cause slight non-uniformities; however, if output has enough intermediate stops, it’s fine).
	•	Swatches in a Palette: If the purpose is to create a palette for data visualization or UI themes (e.g., a series of chart colors or a color scale for a heatmap), the developer could directly use each output color for successive data values or UI elements. For example, in a chart, the first color might be used for lowest value and last for highest, with others in between representing the gradient.
	•	Design Tools Integration: The output being in standard formats means it can be easily imported into design tools (like copy-pasting hex codes into Figma or using them in a design system JSON). Some tools can take arrays of colors to form custom gradients or color scales.

The engine likely ensures the output values are rounded or formatted nicely (e.g., hex in uppercase or lowercase consistently, including the #). Minor details like whether to include a prefix like 0x or not are trivial but important for actual usage. “CSS-compatible” implies including the # for hex and percentage signs for hsl, etc., as needed.

If alpha (transparency) was in scope, they might output rgba() or 8-digit hex. But since problem does not mention transparency we assume fully opaque colors.

Deterministic Order and Content

It’s worth noting that even with random variation, the output array is deterministic given the same inputs. So the developer can rely on the fact that (except if anchors or parameters change) the nth color in the array will always be the same. This allows stable indexing or re-using of certain palette positions. For instance, the developer might know the middle color index and use that as a representative “average color” for some label.

Finally, the engine might also allow output of the journey in a more semantic structure like an object containing configuration and the list. But for conciseness, usually just the array is fine in context.

Deterministic Behavior Guarantees

One of the core promises of the Color Journey Engine is deterministic behavior. This means that the engine functions as a pure mapping from input to output: given identical inputs, it will always produce identical outputs. There are no hidden random seeds (unless explicitly provided for variation), no time-dependent factors, and no external state influencing the result. This guarantee is crucial for developer trust and for using the engine in automated pipelines or version-controlled environments.

Key aspects of this determinism include:
	•	Pure Functionality: The engine can be thought of as a pure function F such that \text{Output} = F(\text{Anchors}, \text{Parameters}, \text{Mode}, \text{Seed}). If you call this function repeatedly with the same arguments, you will get the exact same output array each time. Internally, even if the algorithm uses random number generation, it’s seeded and thus produces a repeatable sequence (no reliance on system time or truly random entropy unless the seed is changed per call, which we do not do unless user wants randomness). This predictability facilitates testing (expected output for known inputs can be validated) and debugging (any deviation indicates a bug or a changed input).
	•	No Hidden State: The engine does not carry over any state from one run to the next. For example, generating one journey and then another will not have any cross-talk (unless explicitly chained by user). There is no notion of “previous palette” affecting the next. Each generation starts fresh with only what’s provided. This is important in contexts like live coding or servers where an engine might be invoked many times; you wouldn’t want, say, the random generator not being reset and thus giving different results because it continued from last use. The design likely resets or re-seeds at each call to ensure independence, or uses the provided seed thoroughly.
	•	Floating-Point Consistency: While we don’t delve into code, it’s worth noting that floating-point arithmetic could in theory introduce tiny nondeterminism across different platforms (due to precision or rounding mode differences). However, these differences are usually negligible for the output (e.g., a 1 unit difference in RGB out of 255 due to rounding differently). The engine could mitigate this by using a standard precision and rounding strategy. But conceptually, we assume a stable environment, so that’s beyond scope. In a formal sense, we could specify that all internal computations are done in a consistent color space with defined transforms, so any conforming implementation will yield the same numeric results to within a rounding tolerance.
	•	Deterministic Variation: The “random” variation, as emphasized, is pseudo-random. The user-provided seed anchors the random sequence. Thus, even though the path might have random wiggles, they are not going to change if you generate the palette again with the same seed. Additionally, if two developers both use seed 123, they get identical palettes. If a user omits the seed but requests variation, the engine might either default to a fixed seed (like 0) – making it still deterministic but just arbitrary – or it might explicitly indicate that nondeterministic behavior is not allowed (some systems forbid using an actual random without a seed because it breaks reproducibility). Most likely, the engine requires a seed to engage variation or has a documented default seed so that it’s still deterministic.
	•	Ordered Output Guarantee: Not only are the color values deterministic, but their order is as well, following the anchor order and loop mode. There’s no scenario where, say, the engine would randomly shuffle the output or something (unless again a weird mode did that by design). So one can rely on C_0 = A_1 etc., always.
	•	Stability Under Minor Implementation Changes: If the engine is updated (like improving the OKLab conversion accuracy or adjusting an algorithm to fix a bug), the outputs for a given input might potentially change. That is outside the direct guarantee at run-time, but in practice versioning would handle that: the user would be aware of engine version. Within the same version, it’s deterministic.

From a developer’s perspective, these guarantees mean the Color Journey Engine can be used in build processes or design pipelines with confidence. For example:
	•	If you generate a palette for a design system and commit it to a repo, regenerating it later (with same config) will produce identical results, avoiding needless diffs or changes.
	•	If an application uses a seed to theme itself (e.g., user enters a “theme code” and gets a color scheme), every instance of the app can generate the same scheme from that code.

In contexts like testing, one can write unit tests that call the engine with a known config and compare output to expected hex codes. The test will pass every time if the engine is deterministic, but if nondeterministic, tests would be flaky.

Determinism also hints that the engine doesn’t do things like incorporate current date/time or external color trends or anything dynamic like that (which it does not; everything is explicit input).

Finally, it’s worth noting that if the engine is multi-threaded or parallel internally, it must handle randomness carefully to remain deterministic. Typically that means each thread gets a portion of the RNG sequence or they use thread-safe RNG with seed, etc. But that’s implementation detail. Conceptually, we treat it as sequential or functional.

Caller Responsibilities

While the Color Journey Engine handles the heavy lifting of generating color sequences given anchors and parameters, there are certain responsibilities and considerations for the caller (i.e., the developer or system using the engine). Ensuring a successful and appropriate use of the engine involves a few things on the caller’s side:
	•	Providing Valid Input: The caller must supply the engine with valid anchor colors and parameters in the expected format and range. For example, anchors should be given as recognizable color values (hex strings like “#34A1EB”, or named colors, or numeric triples depending on API). If the engine expects hex and the caller passes an invalid string, it’s on the caller to correct that. Similarly, dynamic parameter values should be within sensible bounds (the engine might define, say, warmth bias ∈ [-1,1], contrast ≥0, etc.). The engine might perform some validation and reject out-of-range, but it’s best if the caller ensures they pass values in the documented range. The caller should also ensure at least one anchor is provided – an empty anchor list would not define a journey. With one anchor, as discussed, the engine will produce a loop, but if the intention was a transition one might need at least two anchors.
	•	Interpreting and Applying Output: Once the engine returns the swatch array, it is the caller’s job to use those colors meaningfully. The engine doesn’t automatically apply them to an interface or a chart; it just provides the list. The caller might need to assign these colors to UI elements, or write them into a file, etc. For example, if using the palette in a website, the caller writes the CSS or dynamic styles using the output. If the engine outputs 10 colors but the application only needs 5, it’s the caller’s responsibility to decide which to use or to configure the engine to output 5 in the first place.
	•	Maintaining Determinism: The caller should manage the seed if variation is used. If reproducibility is needed, the caller must store or transmit the seed used along with other config. The engine itself won’t remember previous seeds; if the caller wants the “same random palette as before,” they must reuse the same seed. If they neglect to do so or if they request variation with no seed (assuming engine might then default to a random seed each time), they might get inconsistent results. So in contexts like generative art where consistency is needed, callers should explicitly set seeds. Conversely, if a caller wants a different random variant each time (true nondeterministic output), they need to provide a varying seed (like maybe the current time or something); the engine doesn’t inherently do that on its own to avoid breaking determinism. So that choice is on the caller’s side.
	•	Anchors and Color Gamut: The caller should be aware of the color space context of their anchors. If they provide anchors in CSS hex, those are sRGB colors. The engine will interpret them correctly (likely converting to linear sRGB then to XYZ and OKLab). If the caller were to provide a color outside sRGB (say in a larger space like Display P3 by giving coordinates), the engine may not handle it unless explicitly supported because it expects normal colors. Usually, a hex or rgb tuple implies sRGB. If a caller uses weird input like a negative value or “magic” values, it’s not on the engine to guess – the caller should ensure input is within sRGB gamut (0–255 per channel). If not, the engine might clamp or error. So essentially, provide real displayable colors as anchors.
	•	Understanding Engine Limitations: The caller should know the engine’s scope (as described earlier) so they don’t misuse it. For example, if a user interface requires color contrast for accessibility (WCAG contrast ratio between text and background), the engine can produce palettes but doesn’t automatically ensure text is readable if the palette is used on text vs background. The caller would need to check the output for such uses. Possibly, if the engine has an option to enforce a minimum contrast, the caller could set that constraint, but currently we described constraints only generally. So the onus is on the caller to test the palette in their actual context. Another example: if using the palette in a chart, and the chart needs distinct colors for categories, the user should ensure the palette has enough perceptual difference between each step for that purpose. The engine gives uniform differences, which is usually good, but maybe 10 subtle shades of blue might still be hard to distinguish distinctly. The caller might then opt for a larger difference or skipping some intermediate colors. These design decisions are up to the caller.
	•	Performance Considerations: Typically generating a palette is not heavy (unless doing thousands of colors or heavy math repeatedly). But if the caller is in a performance-sensitive environment (like generating colors on every animation frame – which probably isn’t needed, but hypothetically), they should consider caching results. The engine is deterministic, so if called repeatedly with the same inputs, it will always yield the same output. The caller could thus cache a result rather than call the engine 100 times for the same input. This is not a strict requirement, but a typical responsibility for efficiency. Also, if generating extremely large color sequences (maybe someone wants a 256-step gradient for an image), the caller should be aware that output is big and maybe they should directly do interpolation by themselves if that was simpler. But anyway, these are edge concerns.
	•	Upgrading Engine Versions: If the engine is updated (assuming this is a library), the caller is responsible for reading changelogs as slight changes in the algorithm might change outputs. If they want exact reproducibility, they might lock to a version. This is common in any library usage. So while within one run it’s deterministic, across versions the same input might yield slightly different output due to improvements. The engine maintainers would likely document such changes. A cautious caller might include unit tests for critical color outputs to detect if an upgrade changed something unexpectedly.
	•	Integration with Tools: If the palette is handed off to another system (like exporting to a CSS file or JSON), it’s the caller’s job to format it properly if not already formatted. The engine gives CSS strings or hex, which is convenient. But say the caller needs the output in a different color space (like as floats 0–1 for some shader code), they might need to convert themselves (or ask engine for a specific output format if provided). For instance, if developing a game, they might want colors as normalized floats in a GPU buffer. The engine could maybe output that if asked (like an array of triples 0–1). If not, the caller can easily divide the 0–255 values or use conversion functions. It’s straightforward but it is their task.
	•	Handling Edge Cases: The caller should be aware of some edge cases:
	•	If anchors are identical or very close in color, the journey is trivial or degenerate. The engine likely will just produce almost the same color throughout (plus variation if asked). The caller should decide if that’s meaningful or if they should avoid such input (maybe they accidentally gave duplicates).
	•	If only one anchor is given but open loop is requested, does the engine do anything? Perhaps it treats it as closed anyway. The caller should understand how one-anchor case works (we described it loops by default). So they should not expect an open gradient from one color to itself (that would just be that color).
	•	If anchors are at very different lightness or hue, the caller should consider if intermediate colors might go out of gamut. The engine will fix those by clipping, but if one wanted absolutely no clipping, one should ensure anchors themselves are in gamut and maybe not too extreme. Usually not a huge worry because typical colors are fine.
	•	User Experience & Domain Knowledge: If the caller is exposing this engine to end-users (like a UI where users pick anchors and parameters), the caller might want to put friendly interfaces for these parameters (sliders, color pickers, etc.). It’s their responsibility to explain what “warmth” or “vibrancy” means to users, if needed, as the engine is just a backend. In a developer-only context, that might not apply, but it’s something to consider if building a tool around it.

In essence, the engine provides a powerful, but generic capability: constructing color journeys. The caller’s responsibilities include providing correct and sensible inputs, and using the outputs appropriately in their context, as well as managing any aspects of the workflow outside the engine’s scope. By adhering to these responsibilities, the developer ensures the engine can effectively do its job of generating beautiful, perceptually tuned color sequences in a reliable manner.

Conclusion

In this paper, we presented a comprehensive overview of the Color Journey Engine, delving into its conceptual design, mathematical foundations, and the various features that allow fine-grained control over generated color sequences. We discussed how the engine leverages the OKLab perceptual color model to achieve smooth and uniform color transitions ￼, and how anchor-based journey modeling provides a flexible framework to define complex color paths through multiple key points. We introduced the dynamic control parameters – lightness, chroma, warmth, vibrancy, and contrast – explaining how each influences the journey’s shape in perceptual space and allows developers to imbue the output with desired biases or artistic effects. The engine’s support for different looping strategies (open, closed, ping-pong, Möbius) was covered, highlighting how each strategy addresses continuity at the boundaries of the color sequence for cyclic use-cases. We also described the pseudo-random variation mechanism, which injects controlled randomness to produce varied yet reproducible palettes from the same configuration, and emphasized the importance of determinism in the engine’s behavior for reliable use in development workflows.

Throughout, we maintained a high-level, formal perspective: algorithmic formulas were provided for interpolation and bias functions, and we reasoned about the journey construction in terms of curves and transformations in color space, rather than any code. This ensures that the core concepts can be understood and applied independently of implementation language or environment. The output of the engine – an array of color swatches in CSS-friendly formats – was also detailed, underscoring how easily the results can be integrated into real-world applications (from web design to data visualization). Finally, we clarified what lies within the engine’s responsibilities and what lies with the caller, thereby setting clear expectations on how to effectively interact with this system.

In conclusion, the Color Journey Engine exemplifies a marriage of color science and software design: it abstracts the complexity of perceptual color modeling into a tool that developers can use to generate aesthetically pleasing and context-appropriate color sequences with confidence and control. By adjusting a handful of conceptual parameters, one can produce an endless variety of color “journeys” – from subtle, harmonious gradients to bold, contrasting palettes – all while relying on the engine to honor perceptual truths and design constraints. This empowers developers and designers to focus on creative intention (the what) and leave the intricate color mathematics to the engine (the how). The rigorous approach, grounded in models like OKLab and formal interpolation logic, ensures that the outputs are not only visually appealing but also predictable and reproducible – qualities essential for professional use in design systems and generative art alike.

With this foundation, users of the Color Journey Engine can confidently incorporate it into their projects, leveraging high-level controls to achieve their vision, knowing that under the hood the engine is methodically orchestrating a journey through color space that is both artful and scientifically sound.