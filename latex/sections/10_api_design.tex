% ==============================================================================
% Section 10: API Design and Output Structure
% ==============================================================================
% Primary Source: 07_api_design_philosophy.md
% Target Length: 500-1,000 words
% Dependencies: §5 (parameter documentation)
% ==============================================================================

% ------------------------------------------------------------------------------
% 10.1 API Philosophy
% ------------------------------------------------------------------------------
\section{API Philosophy}
\label{sec:api-philosophy}

The engine is a \textbf{pure function} that transforms configuration into palette~\cite{bloch2008}:

\begin{equation*}
    (\text{anchors}, \text{config}) \rightarrow \text{palette}
\end{equation*}

Key characteristics:
\begin{itemize}
    \item \textbf{Stateless} --- No memory between calls
    \item \textbf{Deterministic} --- Same inputs produce same outputs
    \item \textbf{Focused} --- Does one thing well (color journey generation)
    \item \textbf{No side effects} --- No global state, no external dependencies
\end{itemize}

The guiding principle: the engine should do only what the caller cannot do themselves. Complexity belongs in construction, not in the public interface~\cite{gamma1994}.

% ------------------------------------------------------------------------------
% 10.2 Input Parameters
% ------------------------------------------------------------------------------
\section{Input Parameters}
\label{sec:api-input}

\begin{center}
\begin{tabular}{llll}
\toprule
\textbf{Parameter} & \textbf{Type} & \textbf{Required} & \textbf{Description} \\
\midrule
\texttt{count} & integer & Yes & Number of colours to generate \\
\texttt{anchors} & array & Yes & 1--5 colours (hex, RGB, or OKLab) \\
\texttt{temperature} & float & No & $-1$ to $+1$, default $0$ \\
\texttt{intensity} & float & No & $0$ to $1$, default $0.5$ \\
\texttt{smoothness} & float & No & $0$ to $1$, default $0.7$ \\
\texttt{mode} & enum & No & \texttt{journey} or \texttt{categorical} \\
\texttt{loop} & enum & No & \texttt{open}, \texttt{closed}, \texttt{pingpong}, etc. \\
\texttt{seed} & integer & No & Variation seed (omit for no variation) \\
\texttt{preset} & string & No & Named preset (expands to parameters) \\
\bottomrule
\end{tabular}
\end{center}

When a preset is specified, it expands to a parameter set. Explicit parameters override preset defaults.

% ------------------------------------------------------------------------------
% 10.3 Output Structure
% ------------------------------------------------------------------------------
\section{Output Structure}
\label{sec:api-output}

The engine returns discrete swatches (not continuous functions) with three components:

\paragraph{Palette Array.} An ordered list of color swatches, each containing:
\begin{itemize}
    \item \texttt{hex} --- sRGB hex code (\texttt{\#RRGGBB})
    \item \texttt{ok} --- OKLab coordinates (\texttt{\{L, a, b\}})
\end{itemize}

Both sRGB (for immediate use) and OKLab (for further computation) are provided.

\paragraph{Config Echo.} The effective configuration used, enabling reproducibility. Callers can log, store, or transmit the config to regenerate the same palette later.

\paragraph{Diagnostics.} Quality metrics and constraint status for transparency.

% ------------------------------------------------------------------------------
% 10.4 Diagnostic Information
% ------------------------------------------------------------------------------
\section{Diagnostic Information}
\label{sec:api-diagnostics}

Diagnostics report quality metrics and constraint status:

\begin{center}
\begin{tabular}{ll}
\toprule
\textbf{Metric} & \textbf{Description} \\
\midrule
\texttt{minDeltaE} & Smallest perceptual distance between adjacent swatches \\
\texttt{maxDeltaE} & Largest perceptual distance between adjacent swatches \\
\texttt{meanDeltaE} & Average distance \\
\texttt{constraintViolations} & Count of constraint violations \\
\texttt{gamutCorrections} & Count of colours requiring gamut mapping \\
\texttt{traversalStrategy} & Algorithm used (e.g., ``arc-length'') \\
\bottomrule
\end{tabular}
\end{center}

Diagnostics are informational, not prescriptive. The engine does not fail on constraint violations---it reports them and produces output anyway.

% ------------------------------------------------------------------------------
% 10.5 Scope Boundaries (Core vs. Caller)
% ------------------------------------------------------------------------------
\section{Scope Boundaries}
\label{sec:api-scope}

\begin{designdecision}[Engine Core vs.\ Caller Responsibilities]
\textbf{Choice:} The engine core owns palette generation only. Color naming, accessibility checking (WCAG), color blindness simulation, and ICC color management are explicitly caller responsibilities.

\textbf{Rationale:} Keeping the core lean enables production-grade performance (5.6M colours/second) and avoids bloating with features that vary by use case. Language bindings and applications can add these capabilities as needed.

\textbf{Alternatives Considered:}
\begin{itemize}
  \item \textit{Integrated accessibility checking} --- Rejected: varies by standard (WCAG 2.1, 3.0), adds dependencies
  \item \textit{Built-in color naming} --- Rejected: naming systems are culturally/contextually specific
  \item \textit{Color blindness simulation} --- Rejected: simulation algorithms evolve independently
\end{itemize}

\textbf{Reference:} \S\ref{sec:caller-responsibilities}, Appendix~D
\end{designdecision}

Features that can be implemented by callers using the core output are not built into the engine. Examples of excluded features: ``play animation at 30fps'', ``apply palette to image'', ``export to Photoshop swatch file''.

% ------------------------------------------------------------------------------
% 10.6 Performance Characteristics
% ------------------------------------------------------------------------------
\section{Performance Characteristics}
\label{sec:performance}

The C-core implementation achieves production-grade performance:

\begin{center}
\begin{tabular}{ll}
\toprule
\textbf{Metric} & \textbf{Value} \\
\midrule
Per-color generation & Microsecond range \\
Throughput & 5.6 million colours/second\footnote{Measured on Apple M1 hardware, single-threaded, using default configuration (2 anchors, 8 colours, journey mode). Performance varies with configuration complexity and hardware.} \\
Memory & Minimal; no caching required \\
\bottomrule
\end{tabular}
\end{center}

Computational complexity:
\begin{itemize}
    \item Journey construction: $O(1)$ per anchor (fixed-degree Bézier)
    \item Arc-length parameterisation: $O(n)$ precomputation, $O(1)$ lookup
    \item Sampling: $O(n)$ for $n$ colours with constraint checking
\end{itemize}

This performance enables real-time palette generation in interactive applications, eliminates the need for precomputation or caching, and supports high-throughput batch processing.
